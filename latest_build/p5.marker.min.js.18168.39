// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"aZCZP":[function(require,module,exports) {
"use strict";
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = 1234;
var HMR_SECURE = false;
var HMR_ENV_HASH = "439701173a9199ea";
module.bundle.HMR_BUNDLE_ID = "d68ad56631b563d9";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, globalThis, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/"); // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome; // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    } // $FlowFixMe
    ws.onmessage = async function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        acceptedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH); // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear(); // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ✨ Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          🚨 ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>📝 <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", link.getAttribute("href").split("?")[0] + "?" + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
             // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id]; // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"a0t4e":[function(require,module,exports) {
var _core = require("./core");
var _canvasElements = require("./elements/canvas_elements");
var _2DShapeElements = require("./elements/2d_shape_elements");
var _environment = require("./modules/environment");
var _colorElements = require("./elements/color_elements");
var _beyondCanvasElements = require("./elements/beyond_canvas_elements");
var _structure = require("./modules/structure");
var _dom = require("./modules/dom");
var _rendering = require("./modules/rendering");
var _events = require("./modules/events");
var _image = require("./modules/image");
var _io = require("./modules/io");
var _typographyElements = require("./elements/typography_elements");
var _3DShapeElements = require("./elements/3d_shape_elements");
var _3DLightElements = require("./elements/3d_light_elements");
"use strict";
const customElementsDefined = new Event("customElementsDefined");
dispatchEvent(customElementsDefined);

},{"./core":"cTP0J","./elements/canvas_elements":"87F96","./elements/2d_shape_elements":"5HFQ1","./modules/environment":"63Xw9","./elements/color_elements":"4XFJq","./elements/beyond_canvas_elements":"G0ZV5","./modules/structure":"c8QLH","./modules/dom":"d6HpV","./modules/rendering":"2CyQw","./modules/events":"7BjXm","./modules/image":"90xPG","./modules/io":"9XipF","./elements/3d_shape_elements":"lm7DH","./elements/3d_light_elements":"huIwd","./elements/typography_elements":"3u4kq"}],"cTP0J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addP5PropsAndMethods", ()=>addP5PropsAndMethods);
parcelHelpers.export(exports, "P5Element", ()=>P5Element);
parcelHelpers.export(exports, "RenderedElement", ()=>RenderedElement);
var _caseConvert = require("./utils/caseConvert");
var _attrParse = require("./utils/attrParse");
var _p5Modifiers = require("./utils/p5Modifiers");
var _3DMethods = require("./methods/3d_methods");
var _colorProps = require("./properties/color_props");
var _colorMethods = require("./methods/color_methods");
var _dataProps = require("./properties/data_props");
var _dataMethods = require("./methods/data_methods");
var _collideMethods = require("./methods/collide_methods");
var _beyondCanvasElements = require("./elements/beyond_canvas_elements");
var _mathProps = require("./properties/math_props");
var _mathMethods = require("./methods/math_methods");
(0, _p5Modifiers.wrapMethod)("_createFriendlyGlobalFunctionBinder", (base)=>function(options = {}) {
        return (prop, value)=>{
            const descriptor = Object.getOwnPropertyDescriptor(p5.prototype, prop);
            const globalObject = options.globalObject || window;
            if (typeof descriptor === "undefined" || descriptor.writable) return base.call(this, options)(prop, value);
            return Object.defineProperty(globalObject, prop, descriptor);
        };
    });
p5.prototype.assignCanvas = function(c, r) {
    this.noCanvas();
    const mainDiv = document.querySelector("main");
    let index = 0;
    if (typeof c.id === "undefined") while(document.querySelector(`p5MarkerCanvas${index}`))index++;
    c.id = `p5MarkerCanvas${index}`;
    if (mainDiv.children.length === 0) mainDiv.remove();
    if (r === this.WEBGL) this._setProperty("_renderer", new p5.RendererGL(c, this, true));
    else //P2D mode
    this._setProperty("_renderer", new p5.Renderer2D(c, this, true));
    this._renderer._applyDefaults();
    this._setProperty("_elements", [
        this._renderer
    ]);
};
p5.prototype.assets = {};
p5.prototype.loadAssets = async function() {
    const assetElements = Array.from(document.querySelectorAll("p-asset"));
    const pInst = this;
    const promises = assetElements.map((el)=>el.load(pInst));
    const results = await Promise.all(promises);
    results.forEach((result, i)=>this.assets[assetElements[i].getAttribute("name")] = result);
    this._decrementPreload();
};
p5.prototype.registerPreloadMethod("loadAssets", p5.prototype);
p5.prototype._debug_attributes = true;
p5.prototype.create_canvas_element = function(elementName) {
    const createdElement = document.createElement(elementName);
    this.canvas.appendChild(createdElement);
    createdElement.setup(this, this.canvas);
    return createdElement.this_element;
};
(0, _p5Modifiers.defineProperties)({
    object_assign: {
        set: function([target, ...sources]) {
            Object.assign(target, ...sources);
        }
    },
    debug_attributes: {
        get: function() {
            return this._debug_attributes;
        },
        set: function(val) {
            const valType = typeof val;
            if (typeof val === "boolean") this._debug_attributes = val;
            else console.error(`debug_attributes was set to a value of type ${valType} but may only be set to a boolean true/false value.`);
        }
    }
});
const attributePriorities = [
    "debug_attributes",
    "_default",
    "repeat",
    "change", 
];
const addP5PropsAndMethods = (baseClass)=>class P5Extension extends (0, _colorMethods.addColorMethods)((0, _colorProps.addColorConstants)((0, _3DMethods.addWebGLMethods)((0, _collideMethods.addCollide)((0, _mathMethods.addMathMethods)((0, _mathProps.addMathProps)((0, _dataProps.addStorage)((0, _dataMethods.addDataMethods)(baseClass)))))))) {
        /**
     * This element's parent canvas.
     * @private
     */ #canvas;
        #frame_created;
        /**
     * @private
     */ #pInst;
        /**
     * @private
     */ #proxy = new Proxy(this, {
            get (target, prop) {
                return target[prop];
            },
            has (target, prop) {
                return prop in target;
            },
            set (target, prop, val) {
                return target.set(prop, val);
            }
        });
        /**
     * @private
     */ #state = {};
        /**
     * @private
     */ #updateFunctions = new Map();
        #name;
        constructor(){
            super();
            if (this.hasAttribute("name")) (0, _beyondCanvasElements.defineCustomElement)(this);
        }
        /**
     * Proxy for the sibling element above this element with access to its
     * properties, methods, and attributes.
     * @type {proxy}
     */ get above_sibling() {
            return this.previousElementSibling.this_element;
        }
        /**
     * True if siblings directly above this element with an "on" attribute have
     * "on" set to false. This can be used to switch between elements based on
     * conditions, similar to if/else.
     * @type {boolean}
     */ get above_siblings_off() {
            if (this === this.parentElement.firstElementChild) return true;
            const { above_sibling  } = this;
            if (above_sibling.on) return false;
            return above_sibling.above_siblings_off;
        }
        /**
     * @method applyChange
     * @private
     */  #applyChange() {
            const change = this.#state.change = this.#updateAttribute("change");
            let changed = false;
            const assignProp = (obj, prop)=>{
                if (prop in obj) {
                    const changeVal = change[prop];
                    changed ||= obj[prop] !== changeVal;
                    obj[prop] = changeVal;
                    if (this.pInst.debug_attributes) this.setAttribute(prop, changeVal);
                    return true;
                }
                return false;
            };
            for(const prop in change){
                assignProp(this, prop) || assignProp(this.#state, prop) || assignProp(this.pInst, prop) || console.error(`${this.constructor.elementName}'s change attribute has a prop called ${prop} that is unknown`);
                this.#state[prop] = change[prop];
            }
            return changed;
        }
        /**
     * Checks if the provided attribute name belongs to a parent element. If
     * the attribute refers to an object property, this will check for an
     * attribute with a name that matches the object.
     * @param {string} attributeName - name of the attribute to check
     * @returns {boolean} true
     */ attributeInherited(attributeName) {
            const [obj, ...props] = attributeName.split(".");
            if (props.length) return this.attributeInherited(obj);
            if (this.parentElement.hasAttribute(attributeName)) return true;
            if (this.parentElement.attributeInherited) return this.parentElement.attributeInherited(attributeName);
            return false;
        }
        /**
     * Blends the pixels in the display window according to the defined mode.
     * There is a choice of the following modes to blend the source pixels (A)
     * with the ones of pixels already in the display window (B):
     * <ul>
     * <li><code>BLEND</code> - linear interpolation of colours: C =
     * A*factor + B. <b>This is the default blending mode.</b></li>
     * <li><code>ADD</code> - sum of A and B</li>
     * <li><code>DARKEST</code> - only the darkest colour succeeds: C =
     * min(A*factor, B).</li>
     * <li><code>LIGHTEST</code> - only the lightest colour succeeds: C =
     * max(A*factor, B).</li>
     * <li><code>DIFFERENCE</code> - subtract colors from underlying image.
     * <em>(2D)</em></li>
     * <li><code>EXCLUSION</code> - similar to <code>DIFFERENCE</code>, but less
     * extreme.</li>
     * <li><code>MULTIPLY</code> - multiply the colors, result will always be
     * darker.</li>
     * <li><code>SCREEN</code> - opposite multiply, uses inverse values of the
     * colors.</li>
     * <li><code>REPLACE</code> - the pixels entirely replace the others and
     * don't utilize alpha (transparency) values.</li>
     * <li><code>REMOVE</code> - removes pixels from B with the alpha strength of A.</li>
     * <li><code>OVERLAY</code> - mix of <code>MULTIPLY</code> and <code>SCREEN
     * </code>. Multiplies dark values, and screens light values. <em>(2D)</em></li>
     * <li><code>HARD_LIGHT</code> - <code>SCREEN</code> when greater than 50%
     * gray, <code>MULTIPLY</code> when lower. <em>(2D)</em></li>
     * <li><code>SOFT_LIGHT</code> - mix of <code>DARKEST</code> and
     * <code>LIGHTEST</code>. Works like <code>OVERLAY</code>, but not as harsh. <em>(2D)</em>
     * </li>
     * <li><code>DODGE</code> - lightens light tones and increases contrast,
     * ignores darks. <em>(2D)</em></li>
     * <li><code>BURN</code> - darker areas are applied, increasing contrast,
     * ignores lights. <em>(2D)</em></li>
     * <li><code>SUBTRACT</code> - remainder of A and B <em>(3D)</em></li>
     * </ul>
     *
     * <em>(2D)</em> indicates that this blend mode <b>only</b> works in the 2D renderer.<br>
     * <em>(3D)</em> indicates that this blend mode <b>only</b> works in the WEBGL renderer.
     * @type {BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|
     * REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|REMOVE|SUBTRACT}
     */ get blend_mode() {
            if (this.pInst._renderer.isP3D) return this.curBlendMode;
            return this.pInst.drawingContext.globalCompositeOperation;
        }
        set blend_mode(val) {
            this.pInst.blendMode(val);
        }
        /**
     * @private
     */  #callAttributeUpdater(attrName) {
            if (this.#updateFunctions.has(attrName)) {
                const updateFn = this.#updateFunctions.get(attrName);
                return updateFn.call(this);
            }
            if (attrName in this.pInst) return this.pInst[attrName];
            return;
        }
        /**
     * The parent canvas for this element
     * @type {HTMLCanvasElement}
     */ get canvas() {
            return this.#canvas.this_element;
        }
        /**
     * color_mode changes the way p5.js interprets
     * color data. By default, fill,
     * <a href="https://p5js.org/reference/#/p5/color">color()</a> are defined
     * by values between 0 and 255 using the RGB color model. This is equivalent
     * to setting color_mode="RGB, 255".
     * Setting color_mode="HSB" lets you use the HSB system instead. By default,
     * this is color_mode="HSB, 360, 100, 100, 1". You can also use HSL.
     *
     * Note: existing color objects remember the mode that they were created in,
     * so you can change modes as you like without affecting their appearance.
     *
     * @type {RGB|HSB|HSL}
     */ get color_mode() {
            return this.pInst._colorMode;
        }
        set color_mode(val) {
            this.pInst.colorMode(val);
        }
        /**
     * @private
     */ get #comments() {
            return this.#html.split(/(?:\r\n|\r|\n)/).map((line)=>line.match(/.{1,80}/g)).flat().map((line)=>"//	" + line);
        }
        /**
     * The text content of the element and its children. If a $ is followed by
     * the name of a property (such as $blend_mode), it will be replaced by the
     * value of the property.
     */ get content() {
            const getInherited = (owner, prop)=>{
                if (prop in owner) return owner[prop];
                if (owner.parentElement) return getInherited(owner.parentElement, prop);
                return `$${prop}`;
            };
            const textNodes = Array.from(this.childNodes).filter(({ nodeType  })=>nodeType === 3);
            const text = textNodes.map(({ nodeValue  })=>nodeValue).join("").replace(/\$(\w*)/g, (_, prop)=>getInherited(this, prop)).replace(/\\n/g, "\n").trim();
            return text;
        }
        set content(s) {
            if (this.content === s) return;
            for (const node of this.childNodes)if (node.nodeType === 3) this.removeChild(node);
            this.insertBefore(document.createTextNode(s), this.firstChild);
        }
        /**
     * Updates the element's attribute values, renders it to the canvas, and
     * calls the draw method on its children.
     * @method draw
     * @param {object} inherited - object containing attribute values passed
     * down from parent element
     */ draw() {
            if (this.hasAttribute("on")) {
                this.#state.on = this.#updateAttribute("on");
                if (!this.#state.on) return;
            }
            this.pInst.push();
            this.updateState();
            const { content: description  } = this;
            if (description.length) {
                if (this instanceof HTMLCanvasElement) this.pInst.describe(description);
                else this.pInst.describeElement(this.name, description);
            }
            const { WHILE  } = p5.prototype;
            let repeat = true;
            while(repeat){
                this.transform?.();
                this.render?.();
                for (const child of this.children)child.draw?.(this.#state);
                repeat = this.hasAttribute("repeat") && this.#state.repeat;
                const { change  } = this.#state;
                if (Array.isArray(repeat)) {
                    const [key, ...conditions] = this.#updateAttribute("repeat");
                    repeat = key === WHILE === conditions.every((c)=>c);
                }
                if (repeat) {
                    this.pInst.pop();
                    this.pInst.push();
                    const changed = this.#applyChange();
                    const updaters = this.#updateFunctions.entries();
                    for (const [attrName, updater] of updaters)if (attrName in change === false) this.#state[attrName] = this.#updateAttribute(attrName);
                    if (!changed) repeat = false;
                }
                this.endRender?.(this.#state);
            }
            this.pInst.pop();
        }
        /**
     * The p5.js API provides a lot of functionality for creating graphics, but
     * there is some native HTML5 Canvas functionality that is not exposed by
     * p5.
     *
     * You can still assign to
     * it directly using the property `drawing_context`. This is
     * the equivalent of calling `canvas.getContext('2d');` or
     * `canvas.getContext('webgl');` and then calling Object.assign on the
     * result.
     * See this
     * <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D">
     * reference for the native canvas API</a> for possible drawing functions
     * you can call.
     *
     * ```xml
     * <_ drawing_context="shadowOffsetX: 5, shadowOffsetY: -5, shadowBlur: 10,
     * shadowColor: 'black'" />
     * ```
     * @type {Object}
     */ get drawing_context() {
            return this.pInst.drawingContext;
        }
        set drawing_context(obj) {
            Object.assign(this.pInst.drawingContext, obj);
        }
        /**
     * Name of the HTML element generated from this class.
     * @type {string}
     */ static get elementName() {
            return `p-${(0, _caseConvert.pascalToKebab)(this.name)}`;
        }
        /**
     * With erase="true", this element and all elements rendered after it will
     * subtract from the canvas. Erased areas will reveal the web page
     * underneath the canvas. This may be canceled with erase="false"
     *
     * Arguments for the optional parameters to
     * <a href="https://p5js.org/reference/#/p5/erase">erase()</a>
     * may also be provided as a comma separated list.
     *
     * ```<p-image>``` elements will not erase the canvas but works as usual.
     * @type {boolean}
     */ get erase() {
            return this.pInst._renderer._isErasing;
        }
        set erase(val) {
            if (val === true) this.pInst.erase();
            else if (val === false) this.pInst.noErase();
            else if (Array.isArray(val)) this.pInst.erase(...val);
            else console.error(`${this.tagName}'s erase property was set using type ${typeof val}, but erase may only be set to a boolean or array.`);
        }
        /**
     * first_frame is true if the element was just created.
     * This can be used for setup. For example,
     * ```xml
     * <_ rand_ball="this_element">
     *  <_ on="first_frame"
     *     rand_ball.x="random(canvas.width)"
     *     rand_ball.y="random(canvas.height)"></_>
     *   <circle></circle>
     * </_>
     * ```
     * Sets the ```<_>```'s x-coordinate to a random position along the
     * canvas when it is first created. The value then stays the same.
     * As a result, the circle is played at that random position.
     * (read-only)
     * @type {boolean}
     */ get first_frame() {
            return this.frame_count === 1;
        }
        /**
     * frame_count counts the number of frames this element has been
     * rendered. The first time this element is rendered, frame_count
     * with be 1. (read-only)
     * @type {number}
     */ get frame_count() {
            return this.pInst.frameCount - this.#frame_created;
        }
        /**
     * @private
     */ get #html() {
            return this.outerHTML.replace(this.innerHTML, "");
        }
        get name() {
            if (this.#name) return this.#name;
            const elementsWithThisTag = Array.from(document.querySelectorAll(this.tagName));
            return `${this.tagName.slice(2).toLowerCase()}_${elementsWithThisTag.indexOf(this)}`;
        }
        set name(val) {
            this.#name = val;
        }
        /**
     * List of attribute names in the order in which they will be evaluated.
     * Element attributes are not guaranteed to be in the order in which they
     * are written. Transformation attributes are prioritized before others
     * and use this order: anchor, angle, scale_factor, shear.
     * @type {Array}
     */ get orderedAttributeNames() {
            const ordered = Array.from(this.attributes).sort(({ name: a  }, { name: b  })=>(attributePriorities.indexOf(a) + 1 || attributePriorities.indexOf("_default")) - (attributePriorities.indexOf(b) + 1 || attributePriorities.indexOf("_default"))).map(({ name  })=>name);
            return ordered;
        }
        /**
     * Proxy for this element's parent element with access to its properties,
     * methods, and attributes.
     * @type {proxy}
     */ get parent() {
            return this.parentElement.this_element;
        }
        /**
     * This element's p5 instance.
     * @type {object}
     */ get pInst() {
            return this.#pInst;
        }
        render() {}
        /**
     * Sets an attribute's value on this element.
     * @param {string} attributeName
     * @param {*} value
     */ set(attributeName, value) {
            if (attributeName in this) {
                if (this.#updateFunctions.has(attributeName)) this.#updateFunctions.delete(attributeName);
                this[attributeName] = value;
                return true;
            } else if (attributeName in this.pInst) {
                this.#updateFunctions.set(attributeName, ()=>this.pInst[attributeName] = value);
                return true;
            }
            console.error(`${this.tagName}'s ${attributeName} is being set to ${value} by another element, but it doesn't have a property by that name.`);
            return false;
        }
        /**
     * Sets this element up with a p5 instance and sets up its children.
     * @param {p5} pInst
     */ setup(pInst, canvas) {
            this.#pInst = pInst;
            this.#frame_created = pInst.frameCount;
            this.#canvas = canvas;
            this.setDefaults?.();
            this.#setupEvalFns();
            this.setupRenderFunction?.();
            for (const child of this.children)child.setup(pInst, canvas);
        }
        matchExp(str, exp, type, tokens) {
            const [tokenMatch] = str.match(exp);
            const strRemainder = str.slice(tokenMatch.length);
            const matchAdded = tokens.concat({
                type,
                value: tokenMatch
            });
            return this.lexer(strRemainder, matchAdded);
        }
        lexer(str, tokens = []) {
            if (str.length === 0) return tokens;
            if (/^\s/.exec(str)) return this.lexer(str.slice(1), tokens);
            if (/^\d/.exec(str)) return this.matchExp(str, /^\d+(?:\.\d*)?/, "number", tokens);
            if (/^[a-z]\w*\b\(/.exec(str)) return this.matchExp(str, /[a-z].*\b\(/, "methodCallStart", tokens);
            if (/^[a-z]\w*\b[^(]/.exec(str)) return this.matchExp(str, /^\[a-z][a-z\d_]*/, "propertyName", tokens);
            if (/^[+-/*%]/.exec(str)) return this.matchExp(str, /^[+-/*%]/, "arithmeticOperator", tokens);
            if (/^(?:less than|greater than|no more than|at least)/.exec(str)) console.error(`Lexer couldn't find a match on ${this.tagName} for '${str}'`);
        }
        interpret(str) {
            const tokens = this.lexer(str);
            console.log(tokens);
        }
        /**
     * @private
     */  #setupEvalFn(attr) {
            //  The attribute's value will be modified, then run as JS
            const attrJsStr = attr.value;
            //  TODO - catch improperly ordered quote marks: "foo'var"'
            if ((0, _attrParse.AttrParseUtil).allQuotesMatched(attrJsStr) === false) console.error(`It looks like a ${this.tagName}'s ${attr.name} ` + `attribute has an open string. Check that each string has a beginning and end character.`);
            const getAssignPropRef = (str, obj = this)=>{
                //  If string isn't already an array, split it on '.' characters
                const [beforeDot, ...afterDot] = Array.isArray(str) ? str : str.split(".");
                if (afterDot.length === 0) return [
                    obj,
                    beforeDot
                ];
                return getAssignPropRef(afterDot, obj[beforeDot]);
            };
            const [assignObj, assignPropName] = getAssignPropRef(attr.name);
            if (assignObj === this && assignPropName in this === false) this.#customAttributeToProperty(assignPropName);
            this.interpret(attrJsStr);
            const attrValueVarsReplaced = (0, _attrParse.AttrParseUtil).replacePropNames(this, attrJsStr, this instanceof HTMLCanvasElement || assignPropName === "repeat" || assignPropName === "change");
            const varValue = (0, _attrParse.AttrParseUtil).enclose(attrValueVarsReplaced);
            const evalFnName = `${this.tagName.toLowerCase()}_${attr.name}`.replace(/[^a-z0-9]/g, "_");
            const fnHeader = `return function ${evalFnName}() {`;
            const fnBody = `return ${varValue};\n}`;
            const fnStr = [
                fnHeader,
                ...this.#comments,
                fnBody
            ].join("\n");
            const evalFn = new Function(fnStr)();
            const updateFn1 = function() {
                return assignObj[assignPropName] = evalFn.call(this);
            };
            this.#updateFunctions.set(attr.name, updateFn1);
        }
        /**
     * @private
     */  #setupEvalFns() {
            if (this.hasAttribute("repeat") && !this.hasAttribute("change")) {
                console.error(`It looks like a ${this.constructor.elementName} has a repeat attribute ` + "but does not have a change attribute. The change attribute is required to " + "prevent infinite loops.");
                this.removeAttribute("repeat");
            }
            const inheritedAttributes = new Set();
            let obj = this.parent;
            while(obj){
                for (const { name  } of obj.attributes)inheritedAttributes.add(name);
                obj = obj.parent;
            }
            for (const propName of inheritedAttributes){
                if (this.hasAttribute(propName)) continue;
                if (propName in this) this.#updateFunctions.set(propName, ()=>{
                    return this[propName] = this.parent[propName];
                });
                else {
                    console.log(`Setting ${this.tagName}'s ${propName} getter from parent's value`);
                    Object.defineProperty(this, propName, {
                        get: function() {
                            return this.parent[propName];
                        }
                    });
                }
            }
            const { orderedAttributeNames  } = this;
            for(let i = 0; i < orderedAttributeNames.length; i++)this.#setupEvalFn(this.attributes[orderedAttributeNames[i]]);
        }
         #customAttributeToProperty(propName1) {
            console.log(`Creating ${propName1} property on ${this.tagName}`);
            Object.defineProperty(this, propName1, {
                get: function() {
                    return this.#state[propName1];
                },
                set: function(val) {
                    this.#state[propName1] = val;
                }
            });
        }
        /**
     * This element's proxy with access to properties, methods, and attributes.
     */ get this_element() {
            return this.#proxy;
        }
        /**
     * @private
     * @param {*} inherited
     * @param {*} attrName
     * @param {*} thisArg
     * @returns
     */  #updateAttribute(attrName1) {
            const val = this.#callAttributeUpdater(attrName1);
            //  Setting canvas width or height resets the drawing context
            //  Only set the attribute if it's not one of those
            if (this.pInst.debug_attributes === false) return val;
            if (this instanceof HTMLCanvasElement && (attrName1 === "width" || attrName1 === "height")) return val;
            //  Brackets will throw a 'not a valid attribute name' error
            if (attrName1.match(/[\[\]]/)) return val;
            const valToString = (v)=>{
                if (v instanceof p5.Color) return v.toString(this.pInst.color_mode);
                if (typeof v?.toString === "undefined") return v;
                return v.toString();
            };
            this.setAttribute(attrName1, valToString(val));
            return val;
        }
        /**
     * Updates the values of all attributes using the provided expressions.
     * @param {Object} inherited - object
     * @returns
     */ updateState() {
            const updaters = this.#updateFunctions.entries();
            for (const [attrName, updateFunction] of updaters)this.#updateAttribute(attrName);
            return this.#state;
        }
        /**
     * Set attributes for the WebGL Drawing context.
     * This is a way of adjusting how the WebGL
     * renderer works to fine-tune the display and performance.
     *
     * Note that this will reinitialize the drawing context
     * if set after the WebGL canvas is made.
     *
     * If webgl_attributes is set to an object, all attributes
     * not declared in the object will be set to defaults.
     *
     * The available attributes are:
     * <br>
     * alpha - indicates if the canvas contains an alpha buffer
     * default is false
     *
     * depth - indicates whether the drawing buffer has a depth buffer
     * of at least 16 bits - default is true
     *
     * stencil - indicates whether the drawing buffer has a stencil buffer
     * of at least 8 bits
     *
     * antialias - indicates whether or not to perform anti-aliasing
     * default is false (true in Safari)
     *
     * premultipliedAlpha - indicates that the page compositor will assume
     * the drawing buffer contains colors with pre-multiplied alpha
     * default is false
     *
     * preserveDrawingBuffer - if true the buffers will not be cleared and
     * and will preserve their values until cleared or overwritten by author
     * (note that p5 clears automatically on draw loop)
     * default is true
     *
     * perPixelLighting - if true, per-pixel lighting will be used in the
     * lighting shader otherwise per-vertex lighting is used.
     * default is true.
     *
     * @type {Object}
     */ get webgl_attributes() {
            return this.pInst._glAttributes;
        }
        set webgl_attributes(val) {
            this.pInst.setAttributes(...arguments);
        }
    };
class P5Element extends addP5PropsAndMethods(HTMLElement) {
}
class RenderedElement extends P5Element {
    static overloads = [
        ""
    ];
    constructor(){
        super();
        /**
     * @private
     */ this.renderFunctionName ||= (0, _caseConvert.kebabToCamel)(this.tagName.toLowerCase().slice(2));
    }
    /**
   * Sets the parameters used to call this element's render function based
   * on the overloads for that function and this element's attributes.
   * @private
   */  #getArgumentsFromOverloads() {
        const { overloads  } = this.constructor;
        //  Check every required parameter has an attribute
        const isOptional = (param)=>param.match(/^\[.*\]$/);
        let overloadMatch = false;
        //  Split the parameters and start with overloads with most parameters
        const overloadsSplitSorted = overloads.map((o)=>o.split(",").map((p)=>p.trim())).sort((a, b)=>a.length - b.length);
        //  If there aren't any overloads, return an empty array
        if (overloadsSplitSorted.length === 0) return [];
        for(let i = 0; i < overloadsSplitSorted.length; i++){
            const overloadParams = overloadsSplitSorted[i].map((param)=>({
                    name: param.replaceAll(/\[|\]/g, ""),
                    optional: isOptional(param)
                }));
            overloadMatch = i === overloadsSplitSorted.length - 1 || overloadParams.every(({ name , optional  })=>optional || this.hasAttribute(name) || this.attributeInherited(name) || name === "");
            //  If matched overload found
            if (overloadMatch) {
                const lastParamWithAttribute = overloadParams.findLastIndex(({ name , optional  })=>this.hasAttribute(name) || !optional);
                const filteredParams = overloadParams.slice(0, lastParamWithAttribute + 1).map(({ name  })=>name);
                return filteredParams;
            }
        }
        console.error(`Element ${this.tagName} does not have the required attributes to render and will be removed from the sketch`);
        this.remove();
    }
    /**
   * @private
   */ setupRenderFunction() {
        const args = this.#getArgumentsFromOverloads();
        this.render = function() {
            this.pInst[this.renderFunctionName](...args.map((param)=>this[param]));
        };
    }
}
/**
 * The blank `<_>` element renders nothing to the canvas. This is useful
 * for adjusting attributes for child elements.
 * @element _
 */ class _ extends P5Element {
    constructor(){
        super();
    }
}
customElements.define("p-_", _);

},{"./utils/caseConvert":"ctDPl","./utils/attrParse":"dp4Nh","./utils/p5Modifiers":"kkqqW","./methods/3d_methods":"8AVIn","./properties/color_props":"8V5jU","./methods/color_methods":"f7uIM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT","./properties/data_props":"eZaJy","./methods/data_methods":"1U4QU","./methods/collide_methods":"jqqRG","./elements/beyond_canvas_elements":"G0ZV5","./properties/math_props":"hN4D6","./methods/math_methods":"8gdar"}],"ctDPl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "camelToKebab", ()=>camelToKebab);
parcelHelpers.export(exports, "camelToSnake", ()=>camelToSnake);
parcelHelpers.export(exports, "kebabToCamel", ()=>kebabToCamel);
parcelHelpers.export(exports, "pascalToCamel", ()=>pascalToCamel);
parcelHelpers.export(exports, "pascalToKebab", ()=>pascalToKebab);
parcelHelpers.export(exports, "pascalToSnake", ()=>pascalToSnake);
parcelHelpers.export(exports, "snakeToCamel", ()=>snakeToCamel);
//  regex
const upperCaseChar = /([A-Z])/g;
const upperCaseCharAfterFirst = /(?<!^)[A-Z]/g;
//  js string replace 2nd param
const prependMatch = (char)=>char + "$&";
const camelToKebab = (camelStr)=>camelStr.replace(upperCaseCharAfterFirst, prependMatch("-")).toLowerCase();
const camelToSnake = (camelStr)=>camelStr.replace(upperCaseCharAfterFirst, prependMatch("_")).toLowerCase();
const kebabToCamel = (kebabStr)=>kebabStr.replace(/-./g, (s)=>s[1].toUpperCase());
const pascalToCamel = (pascalStr)=>pascalStr.slice(0, 1).toLowerCase() + pascalStr.slice(1);
const pascalToKebab = (pascalStr)=>pascalToCamel(pascalStr).replaceAll(upperCaseChar, (c)=>"-" + c.toLowerCase());
const pascalToSnake = (pascalStr)=>pascalToCamel(pascalStr).replaceAll(upperCaseChar, (c)=>"_" + c.toLowerCase());
const snakeToCamel = (snakeStr)=>snakeStr.split("_").map((s, i)=>i > 0 ? s.slice(0, 1).toUpperCase() + s.slice(1) : s).join("");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jnFvT":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"dp4Nh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AttrParseUtil", ()=>AttrParseUtil);
const notExistingObjProp = "(?<![^\\.]\\.)";
const legalVarName = "\\b[a-z$_][a-z0-9$_]*\\b";
const notNewObjProp = "(?:(?!\\s*:)|(?<=\\?[^,]*))";
const notBoolean = "(?<!\\btrue\\b)(?<!\\bfalse\\b)";
const notNewKeyword = "(?<!\\bnew\\b)";
const notProceededByOpenString = "(?=(?:[^\"'`](?:([\"'`]).*\\1)*)*$)";
const varName = new RegExp(notExistingObjProp + legalVarName + notNewObjProp + notBoolean + notNewKeyword + notProceededByOpenString, "gi");
class AttrParseUtil {
    static regex = {
        legalVarName,
        notExistingObjProp,
        notNewObjProp,
        notBoolean,
        notNewKeyword,
        notProceededByOpenString,
        varName
    };
    static allQuotesMatched(str) {
        const quoteExps = [
            /"/g,
            /'/g,
            /`/g
        ];
        for(const i in quoteExps){
            const matches = str.match(quoteExps[i]);
            if (matches && matches.length % 2 !== 0) return false;
        }
        return true;
    }
    static enclose = (str)=>{
        const strMinusStrings = str.replace(/(["'`]).*?\1/gi, "");
        const items = strMinusStrings.split(/(?<!{[^}]*),/gi);
        const isObject = strMinusStrings.match(/^[^\?\{]*:/gi);
        if (items.length === 1 && !isObject) return str;
        const isUnenclosed = str.match(/(?<!\([^\)]*)(?<!{[^}]*)[,:]/gi) !== null;
        if (!isUnenclosed) return str;
        if (isObject) return `{${str}}`;
        return `[${str}]`;
    };
    static escapes = {
        LESS_THAN: "<",
        GREATER_THAN: ">",
        AT_LEAST: ">=",
        NO_MORE_THAN: "<=",
        AND: "&&",
        OR: "||",
        WHILE: ""
    };
    static isP5 = (name)=>p5.prototype.hasOwnProperty(name);
    static keywords = [
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "debugger",
        "default",
        "delete",
        "do",
        "else",
        "export",
        "extends",
        "false",
        "finally",
        "for",
        "function",
        "if",
        "import",
        "in",
        "instanceof",
        "new",
        "null",
        "return",
        "static",
        "super",
        "switch",
        "this",
        "throw",
        "true",
        "try",
        "typeof",
        "var",
        "void",
        "while",
        "with",
        "yield", 
    ];
    static getOwnerName(el, prop, canReferenceSelf = false) {
        if (canReferenceSelf && prop in el || [
            "this_element",
            "parent",
            "above_sibling",
            "above_siblings_off", 
        ].includes(prop)) return "this";
        if (el.parent && prop in el.parent) return "this.parent";
        if (AttrParseUtil.keywords.includes(prop) || prop in AttrParseUtil.escapes || prop in globalThis) return "none";
        //  TODO - remove this temporary check when no longer needed
        if (prop in el.pInst && prop !== "width" && prop !== "height") return "this.pInst";
        return "inherited";
    }
    static getPrefix(el, prop, canReferenceSelf = false) {
        const ownerName = AttrParseUtil.getOwnerName(el, prop, canReferenceSelf);
        if (ownerName === "none") return "";
        if (ownerName.slice(0, 4) === "this") return `${ownerName}.`;
        else return `_${ownerName}.`;
    }
    static replacePropName(el, prop, canReferenceSelf = false) {
        if (prop in AttrParseUtil.escapes) return AttrParseUtil.escapes[prop];
        return AttrParseUtil.getPrefix(el, prop, canReferenceSelf) + prop;
    }
    static replacePropNames(el, str, canReferenceSelf = false) {
        return str.replace(/UNTIL(.*)/, "!($1)").replace(AttrParseUtil.regex.varName, (prop)=>AttrParseUtil.replacePropName(el, prop, canReferenceSelf));
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kkqqW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defineProperties", ()=>defineProperties);
parcelHelpers.export(exports, "wrapMethod", ()=>wrapMethod);
parcelHelpers.export(exports, "defineSnakeAlias", ()=>defineSnakeAlias);
parcelHelpers.export(exports, "defineRendererGetterSetters", ()=>defineRendererGetterSetters);
var _caseConvert = require("./caseConvert");
function defineProperties(obj) {
    for(const p in obj)p5.prototype[p] = {};
    Object.defineProperties(p5.prototype, obj);
}
const wrapMethod = (methodName, wrapper)=>p5.prototype[methodName] = wrapper(p5.prototype[methodName]);
const defineSnakeAlias = (...propNames)=>propNames.forEach((propName)=>p5.prototype[(0, _caseConvert.camelToSnake)(propName)] = p5.prototype[propName]);
const defineRendererGetterSetters = (...methodNames)=>methodNames.forEach((methodName)=>defineProperties({
            [(0, _caseConvert.camelToSnake)(methodName)]: {
                get: function() {
                    return this._renderer?.[`_${methodName}`];
                },
                set: function(val) {
                    if (Array.isArray(val)) this[methodName](...val);
                    else this[methodName](val);
                }
            }
        }));

},{"./caseConvert":"ctDPl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8AVIn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addWebGLMethods", ()=>addWebGLMethods);
const addWebGLMethods = (baseClass)=>class extends baseClass {
        /**
     * Creates a new <a href="#/p5.Camera">p5.Camera</a> object and sets it
     * as the current (active) camera.
     *
     * The new camera is initialized with a default position
     * (see camera property)
     * and a default perspective projection
     * (see <a href="#/p5.Camera/perspective">perspective()</a>).
     * Its properties can be controlled with the <a href="#/p5.Camera">p5.Camera</a>
     * methods.
     *
     * Note: Every 3D sketch starts with a default camera initialized.
     * This camera can be controlled with the canvas properties
     * camera,
     * perspective, ortho,
     * and frustum if it is the only camera
     * in the scene.
     * @method create_camera
     * @return {p5.Camera} The newly created camera object.
     */ create_camera() {
            this.pInst.createCamera();
        }
        /**
     * Creates a new <a href="#/p5.Shader">p5.Shader</a> object
     * from the provided vertex and fragment shader code.
     *
     * Note, shaders can only be used in WEBGL mode.
     * @method create_shader
     * @param {String} vertSrc source code for the vertex shader
     * @param {String} fragSrc source code for the fragment shader
     * @returns {p5.Shader} a shader object created from the provided
     */ create_shader() {
            this.pInst.createShader(...arguments);
        }
    };

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8V5jU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addColorConstants", ()=>addColorConstants);
parcelHelpers.export(exports, "addStroke", ()=>addStroke);
parcelHelpers.export(exports, "addFill", ()=>addFill);
parcelHelpers.export(exports, "addFillStroke", ()=>addFillStroke);
const addColorConstants = (baseClass)=>class extends baseClass {
        get NONE() {
            return "#0000";
        }
    };
const addStroke = (baseClass)=>class extends baseClass {
        #stroke = "#000";
        #stroke_weight;
        /**
     * Sets the color used to draw lines and borders around shapes. This color
     * is either a <a href="#/p5.Color">p5.Color</a> object or a comma
     * separated list of values to pass into
     * <a href="https://p5js.org/reference/#/p5/color">color()</a>.
     * @type {p5.Color}
     */ get stroke() {
            return this.#stroke;
        }
        set stroke(val) {
            const { pInst  } = this;
            if (val === this.NONE) pInst.noStroke();
            else pInst.stroke(val);
            this.#stroke = pInst.color(pInst._renderer.isP3D ? pInst._renderer.curStrokeColor : pInst.drawingContext.strokeStyle);
        }
        /**
     * Sets the width of the stroke used for lines, points and the border around
     * shapes. All widths are set in units of pixels.
     *
     * Note that it is affected by any transformation or scaling that has
     * been applied previously.
     * @type {number}
     */ get stroke_weight() {
            return this.#stroke_weight;
        }
        set stroke_weight(val) {
            this.pInst.strokeWeight(val);
            this.#stroke_weight = this.pInst._renderer.isP3D ? this.pInst._renderer.curStrokeWeight : this.pInst.drawingContext.lineWidth;
        }
    };
const addFill = (baseClass)=>class extends baseClass {
        #fill = "#fff";
        /**
     * Sets the color used to fill shapes. This may be a
     * <a href="https://p5js.org/reference/#/p5.Color">p5.Color</a> object or
     * a comma separated list of values to pass into
     * <a href="https://p5js.org/reference/#/p5/color">color()</a>.
     * @type {p5.Color}
     */ get fill() {
            return this.#fill;
        }
        set fill(val) {
            const { pInst  } = this;
            if (val === this.NONE) pInst.noFill();
            else pInst.fill(val);
            this.#fill = pInst.color(pInst._renderer.isP3D ? pInst._renderer.curFillColor : pInst.drawingContext.fillStyle);
        }
    };
const addFillStroke = (baseClass)=>class extends addFill(addStroke(baseClass)) {
    };

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f7uIM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addColorMethods", ()=>addColorMethods);
const addColorMethods = (baseClass)=>class extends baseClass {
        lerp_color() {
            return this.pInst.lerpColor(...arguments);
        }
    };

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eZaJy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addStorage", ()=>addStorage);
const addStorage = (baseClass)=>class extends baseClass {
        /**
     * The storage property allows data to be saved in local storage on
     * the device displaying the sketch. This data will remain until the
     * user clears local storage, so you can use this to remember something
     * between uses, such as the high score of a game.
     *
     * To store something, simply add a custom property to storage:
     * ```xml
     * <_ storage.my_property="123" />
     * ```
     * Any element can reference that property.
     * ```xml
     * <square x="storage.my_property" />
     * ```
     * To clear the storage, call the clear method on storage.
     * ```xml
     * <_ _="storage.clear()" />
     * ```
     * To remove a property, call the remove method and pass in the name
     * of the property as a string.
     * ```xml
     * <_ _="storage.remove('my_property')" />
     * ```
     * @type {Proxy}
     */ get storage() {
            return new Proxy(this.pInst, {
                get (target, prop) {
                    if (prop === "clear") return target.clearStorage;
                    if (prop === "remove") return target.removeItem;
                    return target.getItem(prop);
                },
                set (target, prop, val) {
                    target.storeItem(prop, val);
                    return true;
                }
            });
        }
    };

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1U4QU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addDataMethods", ()=>addDataMethods);
const addDataMethods = (baseClass)=>class extends baseClass {
        /**
     *
     * Creates a new instance of p5.StringDict using the key-value pair
     * or the object you provide.
     *
     * @method create_string_dict
     * @param {String} key
     * @param {String} value
     * @returns {p5.StringDict}
     * @method create_string_dict
     * @param {Object} object - key-value pairs
     * @return {p5.StringDict}
     */ create_string_dict() {
            return this.pInst.createStringDict(...arguments);
        }
        /**
     *
     * Creates a new instance of <a href="#/p5.NumberDict">p5.NumberDict</a> using the key-value pair
     * or object you provide.
     *
     * @method create_number_dict
     * @param {Number} key
     * @param {Number} value
     * @return {p5.NumberDict}
     *
     */ /**
     * @method create_number_dict
     * @param {Object} object - key-value pairs
     * @return {p5.NumberDict}
     */ create_number_dict() {
            return this.pInst.createNumberDict(...arguments);
        }
    };

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jqqRG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "collider_type", ()=>collider_type);
parcelHelpers.export(exports, "addCollide", ()=>addCollide);
/*
These methods are adapted from:
Repo: https://github.com/bmoren/p5.collide2D/
Created by http://benmoren.com
Some functions and code modified version from http://www.jeffreythompson.org/collision-detection
Version v0.7.3 | June 22, 2020
CC BY-NC-SA 4.0
*/ class Collide {
    static collider_type = {
        point: "point",
        circle: "circle",
        ellipse: "ellipse",
        rect: "rect",
        line: "line",
        arc: "arc",
        triangle: "triangle",
        poly: "poly"
    };
    #debug = false;
    #element;
    constructor(element){
        this.#element = element;
    }
    get #pInst() {
        return this.#element.pInst;
    }
    get debug() {
        return this.#debug;
    }
    set debug(val) {
        this.#debug = val;
    }
    elements(elementA, elementB) {
        const { collider: colliderA  } = elementA;
        const { collider: colliderB  } = elementB;
        const argsA = elementA.collision_args;
        const argsB = elementB.collision_args;
        const fnNameForward = `${colliderA}_${colliderB}`;
        if (fnNameForward in this) return this[fnNameForward](...argsA, ...argsB);
        const fnNameBackward = `${colliderB}_${colliderA}`;
        if (fnNameBackward in this) return this[fnNameBackward](...argsB, ...argsA);
        console.warn(`Collision check between ${colliderA} and ${colliderB} has not been implemented`);
        return false;
    }
    /*~++~+~+~++~+~++~++~+~+~ 2D ~+~+~++~+~++~+~+~+~+~+~+~+~+~+~+*/ rect_rect(x, y, w, h, x2, y2, w2, h2) {
        //2d
        //add in a thing to detect rectMode CENTER
        if (x + w >= x2 && x <= x2 + w2 && y + h >= y2 && y <= y2 + h2) // r1 bottom edge past r2 top
        return true;
        return false;
    }
    // p5.vector version of collideRectRect
    rect_rect_vector(p1, sz, p2, sz2) {
        return this.rect_rect(p1.x, p1.y, sz.x, sz.y, p2.x, p2.y, sz2.x, sz2.y);
    }
    rect_circle(rx, ry, rw, rh, cx, cy, diameter) {
        //2d
        // temporary variables to set edges for testing
        var testX = cx;
        var testY = cy;
        // which edge is closest?
        if (cx < rx) testX = rx; // left edge
        else if (cx > rx + rw) testX = rx + rw;
         // right edge
        if (cy < ry) testY = ry; // top edge
        else if (cy > ry + rh) testY = ry + rh;
         // bottom edge
        // // get distance from closest edges
        var distance = this.#pInst.dist(cx, cy, testX, testY);
        // if the distance is less than the radius, collision!
        if (distance <= diameter / 2) return true;
        return false;
    }
    // p5.vector version of collideRectCircle
    rect_circle_vector(r, sz, c, diameter) {
        return this.rect_circle(r.x, r.y, sz.x, sz.y, c.x, c.y, diameter);
    }
    circle_circle(x, y, d, x2, y2, d2) {
        //2d
        if (this.#pInst.dist(x, y, x2, y2) <= d / 2 + d2 / 2) return true;
        return false;
    }
    // p5.vector version of collideCircleCircle
    circle_circle_vector(p1, d, p2, d2) {
        return this.circle_circle(p1.x, p1.y, d, p2.x, p2.y, d2);
    }
    point_circle(x, y, cx, cy, d) {
        //2d
        if (this.#pInst.dist(x, y, cx, cy) <= d / 2) return true;
        return false;
    }
    // p5.vector version of collidePointCircle
    point_circle_vector(p, c, d) {
        return this.point_circle(p.x, p.y, c.x, c.y, d);
    }
    point_ellipse(x, y, cx, cy, dx, dy) {
        //2d
        var rx = dx / 2, ry = dy / 2;
        // Discarding the points outside the bounding box
        if (x > cx + rx || x < cx - rx || y > cy + ry || y < cy - ry) return false;
        // Compare the point to its equivalent on the ellipse
        var xx = x - cx, yy = y - cy;
        var eyy = ry * this.#pInst.sqrt(this.#pInst.abs(rx * rx - xx * xx)) / rx;
        return yy <= eyy && yy >= -eyy;
    }
    // p5.vector version of collidePointEllipse
    point_ellipse_vector(p, c, d) {
        return this.point_ellipse(p.x, p.y, c.x, c.y, d.x, d.y);
    }
    point_rect(pointX, pointY, x, y, xW, yW) {
        //2d
        if (pointX >= x && pointX <= x + xW && pointY >= y && pointY <= y + yW) // above the bottom
        return true;
        return false;
    }
    // p5.vector version of collidePointRect
    point_rect_vector(point, p1, sz) {
        return this.point_rect(point.x, point.y, p1.x, p1.y, sz.x, sz.y);
    }
    //  TODO - Accommodate lines with higher stroke_weight
    point_line(px, py, x1, y1, x2, y2, buffer) {
        // get distance from the point to the two ends of the line
        var d1 = this.#pInst.dist(px, py, x1, y1);
        var d2 = this.#pInst.dist(px, py, x2, y2);
        // get the length of the line
        var lineLen = this.#pInst.dist(x1, y1, x2, y2);
        // since floats are so minutely accurate, add a little buffer zone that will give collision
        if (buffer === undefined) buffer = 0.1;
         // higher # = less accurate
        // if the two distances are equal to the line's length, the point is on the line!
        // note we use the buffer here to give a range, rather than one #
        if (d1 + d2 >= lineLen - buffer && d1 + d2 <= lineLen + buffer) return true;
        return false;
    }
    // p5.vector version of collidePointLine
    point_line_vector(point, p1, p2, buffer) {
        return this.point_line(point.x, point.y, p1.x, p1.y, p2.x, p2.y, buffer);
    }
    line_circle(x1, y1, x2, y2, cx, cy, diameter) {
        // is either end INSIDE the circle?
        // if so, return true immediately
        var inside1 = this.point_circle(x1, y1, cx, cy, diameter);
        var inside2 = this.point_circle(x2, y2, cx, cy, diameter);
        if (inside1 || inside2) return true;
        // get length of the line
        var distX = x1 - x2;
        var distY = y1 - y2;
        var len = this.#pInst.sqrt(distX * distX + distY * distY);
        // get dot product of the line and circle
        var dot = ((cx - x1) * (x2 - x1) + (cy - y1) * (y2 - y1)) / this.#pInst.pow(len, 2);
        // find the closest point on the line
        var closestX = x1 + dot * (x2 - x1);
        var closestY = y1 + dot * (y2 - y1);
        // is this point actually on the line segment?
        // if so keep going, but if not, return false
        var onSegment = this.point_line(closestX, closestY, x1, y1, x2, y2);
        if (!onSegment) return false;
        // draw a debug circle at the closest point on the line
        if (this.#debug) this.#pInst.ellipse(closestX, closestY, 10, 10);
        // get distance to closest point
        distX = closestX - cx;
        distY = closestY - cy;
        var distance = this.#pInst.sqrt(distX * distX + distY * distY);
        if (distance <= diameter / 2) return true;
        return false;
    }
    // p5.vector version of collideLineCircle
    line_circle_vector(p1, p2, c, diameter) {
        return this.line_circle(p1.x, p1.y, p2.x, p2.y, c.x, c.y, diameter);
    }
    line_line(x1, y1, x2, y2, x3, y3, x4, y4, calcIntersection) {
        var intersection;
        // calculate the distance to intersection point
        var uA = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
        var uB = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
        // if uA and uB are between 0-1, lines are colliding
        if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
            if (this.#debug || calcIntersection) {
                // calc the point where the lines meet
                var intersectionX = x1 + uA * (x2 - x1);
                var intersectionY = y1 + uA * (y2 - y1);
            }
            if (this.#debug) this.#pInst.ellipse(intersectionX, intersectionY, 10, 10);
            if (calcIntersection) {
                intersection = {
                    x: intersectionX,
                    y: intersectionY
                };
                return intersection;
            } else return true;
        }
        if (calcIntersection) {
            intersection = {
                x: false,
                y: false
            };
            return intersection;
        }
        return false;
    }
    // p5.vector version of collideLineLine
    line_line_vector(p1, p2, p3, p4, calcIntersection) {
        return this.line_line(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, calcIntersection);
    }
    line_rect(x1, y1, x2, y2, rx, ry, rw, rh, calcIntersection) {
        // check if the line has hit any of the rectangle's sides. uses the collideLineLine function above
        var left, right, top, bottom, intersection;
        if (calcIntersection) {
            left = this.line_line(x1, y1, x2, y2, rx, ry, rx, ry + rh, true);
            right = this.line_line(x1, y1, x2, y2, rx + rw, ry, rx + rw, ry + rh, true);
            top = this.line_line(x1, y1, x2, y2, rx, ry, rx + rw, ry, true);
            bottom = this.line_line(x1, y1, x2, y2, rx, ry + rh, rx + rw, ry + rh, true);
            intersection = {
                left: left,
                right: right,
                top: top,
                bottom: bottom
            };
        } else {
            //return booleans
            left = this.line_line(x1, y1, x2, y2, rx, ry, rx, ry + rh);
            right = this.line_line(x1, y1, x2, y2, rx + rw, ry, rx + rw, ry + rh);
            top = this.line_line(x1, y1, x2, y2, rx, ry, rx + rw, ry);
            bottom = this.line_line(x1, y1, x2, y2, rx, ry + rh, rx + rw, ry + rh);
        }
        // if ANY of the above are true, the line has hit the rectangle
        if (left || right || top || bottom) {
            if (calcIntersection) return intersection;
            return true;
        }
        return false;
    }
    // p5.vector version of collideLineRect
    line_rect_vector(p1, p2, r, rsz, calcIntersection) {
        return this.line_rect(p1.x, p1.y, p2.x, p2.y, r.x, r.y, rsz.x, rsz.y, calcIntersection);
    }
    point_poly(px, py, vertices) {
        var collision = false;
        // go through each of the vertices, plus the next vertex in the list
        var next = 0;
        for(var current = 0; current < vertices.length; current++){
            // get next vertex in list if we've hit the end, wrap around to 0
            next = current + 1;
            if (next === vertices.length) next = 0;
            // get the PVectors at our current position this makes our if statement a little cleaner
            var vc = vertices[current]; // c for "current"
            var vn = vertices[next]; // n for "next"
            // compare position, flip 'collision' variable back and forth
            if ((vc.y >= py && vn.y < py || vc.y < py && vn.y >= py) && px < (vn.x - vc.x) * (py - vc.y) / (vn.y - vc.y) + vc.x) collision = !collision;
        }
        return collision;
    }
    // p5.vector version of collidePointPoly
    point_poly_vector(p1, vertices) {
        return this.point_poly(p1.x, p1.y, vertices);
    }
    // POLYGON/CIRCLE
    circle_poly(cx, cy, diameter, vertices, interior) {
        if (interior === undefined) interior = false;
        // go through each of the vertices, plus the next vertex in the list
        var next = 0;
        for(var current = 0; current < vertices.length; current++){
            // get next vertex in list if we've hit the end, wrap around to 0
            next = current + 1;
            if (next === vertices.length) next = 0;
            // get the PVectors at our current position this makes our if statement a little cleaner
            var vc = vertices[current]; // c for "current"
            var vn = vertices[next]; // n for "next"
            // check for collision between the circle and a line formed between the two vertices
            var collision = this.line_circle(vc.x, vc.y, vn.x, vn.y, cx, cy, diameter);
            if (collision) return true;
        }
        // test if the center of the circle is inside the polygon
        if (interior === true) {
            var centerInside = this.point_poly(cx, cy, vertices);
            if (centerInside) return true;
        }
        // otherwise, after all that, return false
        return false;
    }
    // p5.vector version of collideCirclePoly
    circle_poly_vector(c, diameter, vertices, interior) {
        return this.circle_poly(c.x, c.y, diameter, vertices, interior);
    }
    rect_poly(rx, ry, rw, rh, vertices, interior) {
        if (interior == undefined) interior = false;
        // go through each of the vertices, plus the next vertex in the list
        var next = 0;
        for(var current = 0; current < vertices.length; current++){
            // get next vertex in list if we've hit the end, wrap around to 0
            next = current + 1;
            if (next === vertices.length) next = 0;
            // get the PVectors at our current position this makes our if statement a little cleaner
            var vc = vertices[current]; // c for "current"
            var vn = vertices[next]; // n for "next"
            // check against all four sides of the rectangle
            var collision = this.line_rect(vc.x, vc.y, vn.x, vn.y, rx, ry, rw, rh);
            if (collision) return true;
            // optional: test if the rectangle is INSIDE the polygon note that this iterates all sides of the polygon again, so only use this if you need to
            if (interior === true) {
                var inside = this.point_poly(rx, ry, vertices);
                if (inside) return true;
            }
        }
        return false;
    }
    // p5.vector version of collideRectPoly
    rect_poly_vector(r, rsz, vertices, interior) {
        return this.rect_poly(r.x, r.y, rsz.x, rsz.y, vertices, interior);
    }
    line_poly(x1, y1, x2, y2, vertices) {
        // go through each of the vertices, plus the next vertex in the list
        var next = 0;
        for(var current = 0; current < vertices.length; current++){
            // get next vertex in list if we've hit the end, wrap around to 0
            next = current + 1;
            if (next === vertices.length) next = 0;
            // get the PVectors at our current position extract X/Y coordinates from each
            var x3 = vertices[current].x;
            var y3 = vertices[current].y;
            var x4 = vertices[next].x;
            var y4 = vertices[next].y;
            // do a Line/Line comparison if true, return 'true' immediately and stop testing (faster)
            var hit = this.line_line(x1, y1, x2, y2, x3, y3, x4, y4);
            if (hit) return true;
        }
        // never got a hit
        return false;
    }
    // p5.vector version of collideLinePoly
    line_poly_vector(p1, p2, vertice) {
        return this.line_poly(p1.x, p1.y, p2.x, p2.y, vertice);
    }
    poly_poly(p1, p2, interior) {
        if (interior === undefined) interior = false;
        // go through each of the vertices, plus the next vertex in the list
        var next = 0;
        for(var current = 0; current < p1.length; current++){
            // get next vertex in list, if we've hit the end, wrap around to 0
            next = current + 1;
            if (next === p1.length) next = 0;
            // get the PVectors at our current position this makes our if statement a little cleaner
            var vc = p1[current]; // c for "current"
            var vn = p1[next]; // n for "next"
            //use these two points (a line) to compare to the other polygon's vertices using polyLine()
            var collision = this.line_poly(vc.x, vc.y, vn.x, vn.y, p2);
            if (collision) return true;
            //check if the either polygon is INSIDE the other
            if (interior === true) {
                collision = this.point_poly(p2[0].x, p2[0].y, p1);
                if (collision) return true;
                collision = this.point_poly(p1[0].x, p1[0].y, p2);
                if (collision) return true;
            }
        }
        return false;
    }
    poly_poly_vector(p1, p2, interior) {
        return this.poly_poly(p1, p2, interior);
    }
    point_triangle(px, py, x1, y1, x2, y2, x3, y3) {
        // get the area of the triangle
        var areaOrig = this.#pInst.abs((x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1));
        // get the area of 3 triangles made between the point and the corners of the triangle
        var area1 = this.#pInst.abs((x1 - px) * (y2 - py) - (x2 - px) * (y1 - py));
        var area2 = this.#pInst.abs((x2 - px) * (y3 - py) - (x3 - px) * (y2 - py));
        var area3 = this.#pInst.abs((x3 - px) * (y1 - py) - (x1 - px) * (y3 - py));
        // if the sum of the three areas equals the original, we're inside the triangle!
        if (area1 + area2 + area3 === areaOrig) return true;
        return false;
    }
    // p5.vector version of collidePointTriangle
    point_triangle_vector(p, p1, p2, p3) {
        return this.point_triangle(p.x, p.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    }
    point_point(x, y, x2, y2, buffer) {
        if (buffer === undefined) buffer = 0;
        if (this.#pInst.dist(x, y, x2, y2) <= buffer) return true;
        return false;
    }
    // p5.vector version of collidePointPoint
    point_point_vector(p1, p2, buffer) {
        return this.point_point(p1.x, p1.y, p2.x, p2.y, buffer);
    }
    //  TODO - accommodate arcs with unequal width and height
    point_arc(px, py, ax, ay, arcRadius, arcHeading, arcAngle, buffer) {
        if (buffer === undefined) buffer = 0;
        // point
        var point = this.#pInst.createVector(px, py);
        // arc center point
        var arcPos = this.#pInst.createVector(ax, ay);
        // arc radius vector
        var radius = this.#pInst.createVector(arcRadius, 0).rotate(arcHeading);
        var pointToArc = point.copy().sub(arcPos);
        if (point.dist(arcPos) <= arcRadius + buffer) {
            var dot = radius.dot(pointToArc);
            var angle = radius.angleBetween(pointToArc);
            if (dot > 0 && angle <= arcAngle / 2 && angle >= -arcAngle / 2) return true;
        }
        return false;
    }
    // p5.vector version of collidePointArc
    point_arc_vector(p1, a, arcRadius, arcHeading, arcAngle, buffer) {
        return this.point_arc(p1.x, p1.y, a.x, a.y, arcRadius, arcHeading, arcAngle, buffer);
    }
}
const { collider_type  } = Collide;
const addCollide = (baseClass)=>class extends baseClass {
        /**
     * The collide object provides collision detection methods for different
     * shapes. These methods are adapted from
     * <a href="https://github.com/bmoren">Ben Moren's</a>
     * <a href="https://github.com/bmoren/p5.collide2D">Collide2D library</a>.
     * These links are written how these methods would be called in Marker, and
     * they link to the documentation for their corresponding Collide2D
     * function, which has the same parameters:
     * - <a href="https://github.com/bmoren/p5.collide2D#collidepointpoint">
     * collide.point_point()</a>
     * - <a href="https://github.com/bmoren/p5.collide2D#collidepointcircle">
     * collide.point_circle()</a>
     * - <a href="https://github.com/bmoren/p5.collide2D#collidepointellipse">
     * collide.point_ellipse()</a>
     * - <a href="https://github.com/bmoren/p5.collide2D#collidepointrect">
     * collide.point_rect()</a>
     * - <a href="https://github.com/bmoren/p5.collide2D#collidepointline">
     * collide.point_line()</a>
     * - <a href="https://github.com/bmoren/p5.collide2D#collidepointarc">
     * collide.point_arc()</a>
     * - <a href="https://github.com/bmoren/p5.collide2D#colliderectrect">
     * collide.rect_rect()</a>
     * - <a href="https://github.com/bmoren/p5.collide2D#collidecirclecircle">
     * collide.circle_circle()</a>
     * - <a href="https://github.com/bmoren/p5.collide2D#colliderectcircle">
     * collide.rect_circle()</a>
     * - <a href="https://github.com/bmoren/p5.collide2D#collidelineline">
     * collide.line_line()</a>
     * - <a href="https://github.com/bmoren/p5.collide2D#collidelinecircle">
     * collide.line_circle()</a>
     * - <a href="https://github.com/bmoren/p5.collide2D#collidelinerect">
     * collide.line_rect()</a>
     * - <a href="https://github.com/bmoren/p5.collide2D#collidepointpoly">
     * collide.point_poly()</a>
     * - <a href="https://github.com/bmoren/p5.collide2D#collidecirclepoly">
     * collide.circle_poly()</a>
     * - <a href="https://github.com/bmoren/p5.collide2D#colliderectpoly">
     * collide.rect_poly()</a>
     * - <a href="https://github.com/bmoren/p5.collide2D#collidelinepoly">
     * collide.line_poly()</a>
     *- <a href="https://github.com/bmoren/p5.collide2D#collidepolypoly">
     * collide.poly_poly()</a>
     * - <a href="https://github.com/bmoren/p5.collide2D#collidepointtriangle">
     * collide.point_triangle()</a>
     */ collide = new Collide(this);
        /**
     * Checks if this element is colliding with the provided other element.
     * @method colliding_with
     * @param {P5Element} el - other element to check
     * @returns {boolean} true if elements are colliding
     */ colliding_with(el) {
            return this.collide.elements(this, el);
        }
    };

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"G0ZV5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defineCustomElement", ()=>defineCustomElement);
const defineCustomElement = (el)=>{
    const name = el.getAttribute("name");
    //  Trick custom-elements-manifest into ignoring this
    customElements["define"](`p-${name}`, class extends el.constructor {
        renderFunctionName = el.renderFunctionName;
        constructor(){
            super();
        }
        /**
       * Sets the default values for this element's attributes.
       */ setDefaults() {
            Array.from(el.attributes).forEach((a)=>this.hasAttribute(a.name) === false && this.setAttribute(a.name, a.value));
            const childClones = Array.from(el.children).map((child)=>child.cloneNode(true));
            this.prepend(...childClones);
        }
        renderToCanvas = null;
    });
};
/**
 * This HTML element loads an XML sketch file. This should be added to the
 * index.html file as a `<link>` element with the attributes is="p-sketch" and
 * href="[PATH TO XML FILE]".
 * @element p-sketch
 * @example Add a sketch to html
 * ```html
 * <!DOCTYPE html>
 * <html lang="en">
 * <head>
 *   <script src="p5.js"></script>
 *   <script src="p5.marker.js" defer></script>
 *   <link rel="stylesheet" type="text/css" href="style.css" />
 *   <link href="sketch.xml" is="p-sketch" />
 *   <meta charset="utf-8" />
 * </head>
 * <body></body>
 * </html>
 * ```
 */ class Sketch extends HTMLLinkElement {
    static elementName = "p-sketch";
    constructor(){
        super();
        this.#loadXML(this.href);
    }
     #convertElement(xmlEl) {
        const xmlTag = xmlEl.tagName;
        const createElementArguments = this.#xmlTagToCreateElementArguments(xmlTag);
        const pEl = document.createElement(...createElementArguments);
        this.#copyAttributes(xmlEl, pEl);
        for (const childNode of xmlEl.childNodes)if (childNode.nodeType === 1) pEl.appendChild(this.#convertElement(childNode));
        else pEl.appendChild(childNode.cloneNode());
        if (pEl.hasAttribute("name")) defineCustomElement(pEl);
        return pEl;
    }
     #convertXML(e) {
        const xml = e.target.response.documentElement;
        document.body.appendChild(this.#convertElement(xml));
        document.querySelectorAll("canvas").forEach((canvas)=>canvas.runCode());
    }
     #copyAttributes(orig, copy) {
        const attrs = orig.attributes;
        for(let i = 0; i < attrs.length; i++){
            const attr = attrs[i];
            copy.setAttribute(attr.name, attr.value);
        }
    }
     #loadXML(path) {
        if (!path) return console.error("p-sketch element is missing required path attribute");
        const request = new XMLHttpRequest();
        request.open("GET", path);
        request.responseType = "document";
        request.overrideMimeType("text/xml");
        request.addEventListener("load", this.#convertXML.bind(this));
        request.send();
    }
     #xmlTagToCreateElementArguments(xmlTag1) {
        if (xmlTag1.slice(0, 2) === "p-") return [
            xmlTag1
        ];
        if (xmlTag1 === "canvas") return [
            xmlTag1,
            {
                is: "p-canvas"
            }
        ];
        if (xmlTag1 === "canvas-3d") return [
            "canvas",
            {
                is: "p-canvas-3d"
            }
        ];
        return [
            "p-" + xmlTag1
        ];
    }
}
customElements.define("p-sketch", Sketch, {
    extends: "link"
});
class Asset extends HTMLElement {
    static elementName = "p-asset";
    constructor(){
        super();
    }
    static loadFns = {
        image: "loadImage",
        font: "loadFont",
        json: "loadJSON",
        strings: "loadStrings",
        table: "loadTable",
        xml: "loadXML",
        bytes: "loadBytes",
        get: "httpGet",
        shader: "loadShader"
    };
    async load(pInst) {
        if (this.data) return this.data;
        const loadFn = Asset.loadFns[this.getAttribute("type").toLowerCase()];
        const path = this.getAttribute("path");
        this.data = await pInst[loadFn](path);
        return this.data;
    }
}
customElements.define("p-asset", Asset);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hN4D6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addMathProps", ()=>addMathProps);
const addMathProps = (baseClass)=>class extends baseClass {
        #angle_mode = p5.RADIANS;
        #perlin_octaves = 4;
        #perlin_amp_falloff = 0.5;
        #noise_seed;
        #random_seed;
        get angle_mode() {
            return this.#angle_mode;
        }
        set angle_mode(mode) {
            this.pInst.angleMode(mode);
            this.#angle_mode = this.pInst._angleMode;
        }
        /**
     * math provides access to the built-in Math object available on browsers.
     * The reference for the Math object is available at
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math.
     */ get math() {
            return Math;
        }
        /**
     * Adjusts the character and level of detail produced by the Perlin noise
     * method. This must be set to a comma-separated list of 2 numbers:
     * 1. lod: number of octaves to be used by the noise
     * 2. falloff:  falloff factor for each octave
     *
     * Similar to harmonics in physics, noise is computed over
     * several octaves. Lower octaves contribute more to the output signal and
     * as such define the overall intensity of the noise, whereas higher octaves
     * create finer-grained details in the noise sequence.
     *
     * By default, noise is computed over 4 octaves with each octave contributing
     * exactly half as much as its predecessor, starting at 50% strength for the 1st
     * octave. This falloff amount can be changed by adding an additional function
     * parameter. Eg. a falloff factor of 0.75 means each octave will now have
     * 75% impact (25% less) of the previous lower octave. Any value between
     * 0.0 and 1.0 is valid, however, note that values greater than 0.5 might
     * result in greater than 1.0 values returned by noise().
     *
     * By changing these values, the signal created by the noise()
     * method can be adapted to fit very specific needs and characteristics.
     * @type {[number, number]}
     */ get noise_detail() {
            return [
                this.#perlin_octaves,
                this.#perlin_amp_falloff
            ];
        }
        set noise_detail(val) {
            this.pInst.noiseDetail(...val);
        }
        /**
     * Sets the seed value for noise(). By default,
     * noise() produces different results each time
     * the program is run. Set the `seed` value to a constant to return
     * the same pseudo-random numbers each time the software is run.
     * If a seed has not been set, noise_seed will be undefined.
     * @type {number}
     */ get noise_seed() {
            return this.#noise_seed;
        }
        set noise_seed(val) {
            this.pInst.noiseSeed(val);
        }
        /**
     * Sets the seed value for random().
     *
     * By default, random() produces different results each time the program
     * is run. Set random_seed to a constant to return the same
     * pseudo-random numbers each time the software is run. If a seed has not
     * been set, random_seed will be undefined.
     * @type {number}
     */ get random_seed() {
            return this.#random_seed;
        }
        set random_seed(val) {
            this.pInst.randomSeed(val);
            this.#random_seed = val;
        }
    };

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8gdar":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addMathMethods", ()=>addMathMethods);
const addMathMethods = (baseClass)=>class extends baseClass {
        /**
     * Creates a new <a href="#/p5.Vector">p5.Vector</a> (the datatype for storing vectors). This provides a
     * two or three-dimensional vector, specifically a Euclidean (also known as
     * geometric) vector. A vector is an entity that has both magnitude and
     * direction.
     * @param {Number} [x] x component of the vector
     * @param {Number} [y] y component of the vector
     * @param {Number} [z] z component of the vector
     * @return {p5.Vector}
     */ vector() {
            return this.pInst.createVector(...arguments);
        }
    };

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"87F96":[function(require,module,exports) {
var _core = require("../core");
var _canvasProps = require("../properties/canvas_props");
var _canvasMethods = require("../methods/canvas_methods");
var _environmentProps = require("../properties/environment_props");
/**
 * The `<canvas>` element is a rectangular area of the window for rendering
 * imagery. All child elements are rendered to the canvas.
 *
 * This canvas will render 2D elements only. For a 3D canvas, use
 * ```<canvas-3d>```.
 */ class Canvas extends (0, _canvasMethods.addCanvasMethods)((0, _canvasProps.addCanvasProperties)((0, _core.addP5PropsAndMethods)((0, _environmentProps.addEnvironmentProps)(HTMLCanvasElement)))) {
    static renderer = "p2d";
    constructor(){
        super();
        window.addEventListener("customElementsDefined", this.runCode.bind(this));
    }
}
customElements.define("p-canvas", Canvas, {
    extends: "canvas"
});
/**
 * The ```<canvas-3d>``` element is a ```<canvas>``` element
 * for rendering 3D elements.
 */ class WebGLCanvas extends (0, _canvasMethods.addCanvasMethods)((0, _canvasProps.addCanvasProperties)((0, _core.addP5PropsAndMethods)((0, _environmentProps.addEnvironmentProps)(HTMLCanvasElement)))) {
    #bezier_detail;
    #curve_detail;
    #debug_mode;
    #orbit_control;
    static renderer = "webgl";
    constructor(){
        super();
        window.addEventListener("customElementsDefined", this.runCode.bind(this));
    }
    /**
   * Sets the resolution at which Bezier's curve is displayed. The default value is 20.
   * @type {number}
   */ get bezier_detail() {
        return this.#bezier_detail;
    }
    set bezier_detail(val) {
        this.pInst.bezierDetail(val);
        this.#bezier_detail = this.pInst._bezierDetail;
    }
    /**
   * Sets the current (active) camera of a 3D sketch.
   * Allows for switching between multiple cameras.
   *
   * Comma-separated arguments for
   * <a href="https://p5js.org/reference/#/p5/camera">camera()</a>
   * may also be provided to adjust the current camera.
   *
   * @type {p5.Camera}
   * */ get camera() {
        return this.pInst._renderer._curCamera;
    }
    set camera(val) {
        const { pInst  } = this;
        if (val instanceof p5.Camera) pInst.setCamera(val);
        else if (Array.isArray(val)) pInst.camera(...val);
        else pInst.camera(val);
    }
    /**
   * Sets the resolution at which curves display. The default value is 20 while
   * the minimum value is 3.
   * @type {number}
   */ get curve_detail() {
        return this.#curve_detail;
    }
    set curve_detail(val) {
        this.pInst.curveDetail(val);
        this.#curve_detail = this.pInst._curveDetail;
    }
    /**
   * debug_mode helps visualize 3D space by adding a grid to indicate where the
   * ‘ground’ is in a sketch and an axes icon which indicates the +X, +Y, and +Z
   * directions. This property can be set to "true" to create a
   * default grid and axes icon, or it can be set to a comma-separated list
   * of values to pass into
   * <a href="https://p5js.org/reference/#/p5/debugMode">debugMode()</a>.
   *
   * By default, the grid will run through the origin (0,0,0) of the sketch
   * along the XZ plane
   * and the axes icon will be offset from the origin.  Both the grid and axes
   * icon will be sized according to the current canvas size.
   * Note that because the
   * grid runs parallel to the default camera view, it is often helpful to use
   * debug_mode along with orbit_control to allow full view of the grid.
   * @type {boolean}
   */ get debug_mode() {
        return this.#debug_mode;
    }
    set debug_mode(val) {
        const { pInst  } = this;
        if (val === false) {
            pInst.noDebugMode();
            this.#debug_mode = false;
            return;
        } else if (val === true) pInst.debugMode();
        else if (Array.isArray(val)) pInst.debugMode(...val);
        else pInst.debugMode(val);
        this.#debug_mode = true;
    }
    /**
   * Allows movement around a 3D sketch using a mouse or trackpad.
   * Left-clicking and dragging will rotate the camera position about the
   * center of the sketch,
   * right-clicking and dragging will pan the camera position without rotation,
   * and using the mouse wheel (scrolling) will move the camera closer or
   * further
   * from the center of the sketch. This property can be set with parameters
   * dictating sensitivity to mouse movement along the X, Y, and Z axes.
   * Setting orbit_control="true" is equivalent to setting
   * orbit_control="1, 1".
   * To reverse direction of movement in either axis, enter a negative number
   * for sensitivity.
   * @type {boolean}
   * */ get orbit_control() {
        return this.#orbit_control;
    }
    set orbit_control(val) {
        this.#orbit_control = val;
    }
    /**
   * Sets an orthographic projection for the current camera in a 3D sketch
   * and defines a box-shaped viewing frustum within which objects are seen.
   * In this projection, all objects with the same dimension appear the same
   * size, regardless of whether they are near or far from the camera.
   *
   * This may be set to a comma-separated list of arguments to
   * <a href="https://p5js.org/reference/#/p5/ortho">ortho()</a>
   *
   * If set to "true", the following default is used:
   * ortho(-width/2, width/2, -height/2, height/2).
   *
   * @type {boolean}
   */ set ortho(val) {
        if (val === true) this.pInst.ortho();
        else if (Array.isArray(val)) this.pInst.ortho(...val);
        else if (val !== false) this.pInst.ortho(val);
    }
}
customElements.define("p-canvas-3d", WebGLCanvas, {
    extends: "canvas"
});

},{"../core":"cTP0J","../properties/canvas_props":"f7aAh","../methods/canvas_methods":"jLVJN","../properties/environment_props":"c8eYf"}],"f7aAh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addCanvasProperties", ()=>addCanvasProperties);
const addCanvasProperties = (baseClass)=>class extends baseClass {
        #background;
        /**
     * The background property sets the color or image used
     * for the background of the p5.js canvas. The default background is transparent.
     * A <a href="https://p5js.org/reference/#/p5.Color">p5.Color</a> object can be provided to set the background color.
     *
     * A <a href="https://p5js.org/reference/#/p5.Image">p5.Image</a> can also be provided to set the background image.
     *
     * The arguments to <a href="https://p5js.org/reference/#/p5/color">color()</a> can also be provided,
     * separated by commas.
     * @type {p5.Color|p5.Image}
     */ get background() {
            return this.#background;
        }
        set background(c) {
            if (c instanceof p5.Color || c instanceof p5.Image) this.#background = c;
            this.#background = this.pInst.color(c);
        }
        /**
     * Sets the cursor when hovering over the canvas.
     *
     * You can set cursor to any of the following constants:
     * ARROW, CROSS, HAND, MOVE, TEXT and WAIT
     *
     * You may also set cursor to the URL of an image file. The recommended size
     * is 16x16 or 32x32 pixels. (Allowed File extensions: .cur, .gif, .jpg, .jpeg, .png)
     *
     * For more information on Native CSS cursors and url visit:
     * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor
     *
     * You may also set cursor to "type, x, y", where type is one of the types above,
     * x is the horizontal active spot of the cursor (must be less than 32)
     * and
     * y is the vertical active spot of the cursor (must be less than 32)
     * @type {string}
     */ get cursor() {
            return this.style.cursor;
        }
        set cursor(val) {
            const { pInst  } = this;
            if (val === this.NONE) pInst.noCursor();
            else if (Array.isArray(val)) pInst.cursor(...val);
            else pInst.cursor(val);
        }
        /**
     * The height of the canvas in pixels.
     * @type {number}
     */ get height() {
            return this.pInst.height;
        }
        set height(val) {
            if (val === this.height || isNaN(val)) return;
            this.#resize(this.width, val);
        }
        get orderedAttributeNames() {
            //  Remove 'is' and 'style' from attrNames
            return super.orderedAttributeNames.filter((v)=>v !== "is" && v != "style");
        }
        /**
     * Array containing the values for all the pixels in the display window.
     * These values are numbers. This array is the size (include an appropriate
     * factor for pixel_density) of the display window x4,
     * representing the R, G, B, A values in order for each pixel, moving from
     * left to right across each row, then down each column. Retina and other
     * high density displays may have more pixels (by a factor of
     * pixel_density^2).
     * For example, if the image is 100×100 pixels, there will be 40,000. With
     * pixel_density = 2, there will be 160,000. The first four values
     * (indices 0-3) in the array will be the R, G, B, A values of the pixel at
     * (0, 0). The second four values (indices 4-7) will contain the R, G, B, A
     * values of the pixel at (1, 0).
     * @type {number[]}
     */ get pixels() {
            this.pInst.loadPixels();
            return this.pInst.pixels;
        }
        set pixels(px) {
            this.pInst.pixels = px;
            this.pInst.updatePixels();
        }
        set loop(val) {
            if (val) this.pInst.loop();
            else this.pInst.noLoop();
        }
         #resize(w, h) {
            if (w === this.width && h === this.height) return;
            const { pInst  } = this;
            const props = {};
            for(const key in pInst.drawingContext){
                const val = pInst.drawingContext[key];
                if (typeof val !== "object" && typeof val !== "function") props[key] = val;
            }
            pInst.width = pInst._renderer.width = w;
            pInst.height = pInst._renderer.height = h;
            this.setAttribute("width", w * pInst._pixelDensity);
            this.setAttribute("height", h * pInst._pixelDensity);
            this.style.width = `${w}px`;
            this.style.height = `${h}px`;
            pInst.drawingContext.scale(pInst._pixelDensity, pInst._pixelDensity);
            for(const savedKey in props)try {
                pInst.drawingContext[savedKey] = props[savedKey];
            } catch (err) {}
            pInst.drawingContext.scale(pInst._pixelDensity, pInst._pixelDensity);
            pInst.redraw();
        }
        /**
     * The width of the canvas in pixels.
     * @type {number}
     */ get width() {
            return this.pInst.width;
        }
        set width(val) {
            if (val === this.width || isNaN(val)) return;
            this.#resize(val, this.height);
        }
    };

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jLVJN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addCanvasMethods", ()=>addCanvasMethods);
const addCanvasMethods = (baseClass)=>class extends baseClass {
        attributeInherited(attributeName) {
            if (this.hasAttribute(attributeName) || attributeName in this.defaults) return true;
            return super.attributeInherited(attributeName);
        }
        runCode() {
            const canvas = this;
            const sketch = (pInst)=>{
                canvas.defaults = {
                    x: 0,
                    x1: 0,
                    x2: 0,
                    x3: 100,
                    x4: 100,
                    cx: 0,
                    y: 0,
                    y1: 0,
                    y2: 100,
                    y3: 100,
                    y4: 0,
                    cy: 0,
                    z: 0,
                    w: 100,
                    h: 100,
                    d: 100,
                    size: 100,
                    start_angle: 0,
                    stop_angle: pInst.PI,
                    v1: 255,
                    v2: 255,
                    v3: 255,
                    rx: 1,
                    ry: 1,
                    rz: -1,
                    img: pInst.createImage(100, 100),
                    on: true,
                    repeat: false,
                    change: {}
                };
                pInst.preload = ()=>pInst.loadAssets();
                pInst.setup = function() {
                    canvas.setup(pInst, canvas);
                    // Set default dimensions (100, 100)
                    canvas.width = 100;
                    canvas.height = 100;
                    //  Set default background to transparent
                    canvas.background = pInst.color(0, 0);
                    pInst.assignCanvas(canvas, canvas.constructor.renderer);
                };
                pInst.draw = function() {
                    if (canvas.orbit_control) canvas.pInst.orbitControl();
                    canvas.draw(canvas.defaults);
                };
            };
            new p5(sketch);
        }
        render() {
            this.pInst.background(this.background);
        }
    };

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"c8eYf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addEnvironmentProps", ()=>addEnvironmentProps);
var _p5Modifiers = require("../utils/p5Modifiers");
p5.prototype.window_resized = false;
(0, _p5Modifiers.wrapMethod)("_onresize", (base)=>function(e) {
        base.call(this, e);
        this._setProperty("window_resized", true);
    });
p5.prototype.registerMethod("post", function() {
    this._setProperty("window_resized", false);
});
class Window {
    #element;
    constructor(element){
        this.#element = element;
    }
    get #pInst() {
        return this.#element.pInst;
    }
    /**
   * window_resized is true if the window was resized since the last frame
   * and false if not (read-only)
   * @type {boolean}
   * @readonly
   */ get resized() {
        return this.#pInst.window_resized;
    }
    get width() {
        return this.#pInst.windowWidth;
    }
    get height() {
        return this.#pInst.windowHeight;
    }
}
const addEnvironmentProps = (baseClass)=>class extends baseClass {
        get fullscreen() {
            return this.pInst.fullscreen();
        }
        set fullscreen(val) {
            this.pInst.fullscreen(val);
        }
        /**
     * frame_rate specifies the number of frames to be displayed every second.
     * For example,
     * frame_rate="30" will attempt to refresh 30 times a second.
     * If the processor is not fast enough to maintain the specified rate, the
     * frame rate will not be achieved. The default frame rate is
     * based on the frame rate of the display (here also called "refresh rate"),
     * which is set to 60 frames per second on most computers.
     * A frame rate of 24
     * frames per second (usual for movies) or above will be enough for smooth
     * animations.
     *
     * The canvas must be rendered at least once for frame_rate to have a
     * value.
     * @type {number}
     */ get frame_rate() {
            return this.pInst._frameRate;
        }
        set frame_rate(val) {
            this.pInst.frameRate(val);
        }
        /**
     * pixel_density specifies the pixel scaling for high pixel density displays.
     * By default pixel density is set to match display density, set pixel_density="1"
     * to turn this off.
     * @type {number}
     */ get pixel_density() {
            return this.pInst.pixelDensity();
        }
        set pixel_density(val) {
            this.pInst.pixelDensity(val);
        }
        /**
     * The pixel density of the current display the sketch is running on. (read-only)
     * @type {number}
     * @readonly
     */ get display_density() {
            return this.pInst.displayDensity();
        }
        /**
     * The delta_time property contains the time
     * difference between the beginning of the previous frame and the beginning
     * of the current frame in milliseconds.
     *
     * This variable is useful for creating time sensitive animation or physics
     * calculation that should stay constant regardless of frame rate.
     * (read-only)
     * @readonly
     * @type {number}
     */ get delta_time() {
            return this.pInst.deltaTime;
        }
        /**
     * screen stores information about the screen displaying the canvas.
     * To get the dimensions of the screen, use:
     * ```
     * screen.width
     * screen.height
     * ```
     * screen is available in any browser and is not specific to this
     * library.
     * The full documentation is here:
     * https://developer.mozilla.org/en-US/docs/Web/API/Screen
     * (read-only)
     * @readonly
     */ get screen() {
            return screen;
        }
        /**
     * The window object provides information about the window containing the
     * canvas.
     * - window.width   - number: width of the window
     * - window.height  - number: height of the window
     * - window.resized - boolean: true if the window was resized since last
     * frame
     * @type {Object}
     */ get window() {
            return this.#window;
        }
        #window = new Window(this);
        /**
     * grid_output lays out the
     * content of the canvas in the form of a grid (html table) based
     * on the spatial location of each shape. A brief
     * description of the canvas is available before the table output.
     * This description includes: color of the background, size of the canvas,
     * number of objects, and object types (example: "lavender blue canvas is
     * 200 by 200 and contains 4 objects - 3 ellipses 1 rectangle"). The grid
     * describes the content spatially, each element is placed on a cell of the
     * table depending on its position. Within each cell an element the color
     * and type of shape of that element are available (example: "orange ellipse").
     * These descriptions can be selected individually to get more details.
     * A list of elements where shape, color, location, and area are described
     * (example: "orange ellipse location=top left area=1%") is also available.
     *
     * grid_output="true" and grid_output="FALLBACK"
     * make the output available in
     * <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Hit_regions_and_accessibility" target="_blank">
     * a sub DOM inside the canvas element</a> which is accessible to screen readers.
     * grid_output="LABEL" creates an
     * additional div with the output adjacent to the canvas, this is useful
     * for non-screen reader users that might want to display the output outside
     * of the canvas' sub DOM as they code. However, using LABEL will create
     * unnecessary redundancy for screen reader users. We recommend using LABEL
     * only as part of the development process of a sketch and removing it before
     * publishing or sharing with screen reader users.
     * @type {true|LABEL|FALLBACK}
     */ get grid_output() {
            return this._accessibleOutputs.grid;
        }
        set grid_output(val) {
            if (val === true) this.pInst.gridOutput();
            else this.pInst.gridOutput(val);
        }
    };

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT","../utils/p5Modifiers":"kkqqW"}],"5HFQ1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addArcProps", ()=>addArcProps);
parcelHelpers.export(exports, "addDiameter", ()=>addDiameter);
parcelHelpers.export(exports, "addShapeElementProps", ()=>addShapeElementProps);
var _core = require("../core");
var _shapeMethods = require("../methods/shape_methods");
var _colorProps = require("../properties/color_props");
var _shapeProps = require("../properties/shape_props");
var _collideMethods = require("../methods/collide_methods");
var _transformProps = require("../properties/transform_props");
var _transformMethods = require("../methods/transform_methods");
const add2DStroke = (baseClass)=>(0, _colorProps.addStroke)((0, _shapeProps.add2DStrokeStyling)(baseClass));
const add2DFillStroke = (baseClass)=>(0, _colorProps.addFillStroke)((0, _shapeProps.add2DStrokeStyling)(baseClass));
const transformVertexFn = (el)=>(v)=>{
        const { x , y  } = el.local_to_canvas_position(v.x, v.y);
        return el.pInst.createVector(x, y);
    };
class Transformed2DElement extends (0, _transformProps.add2DTransformProps)((0, _transformMethods.add2DTransformMethods)((0, _core.RenderedElement))) {
}
const addArcProps = (baseClass)=>class extends baseClass {
        #start_angle = 0;
        #stop_angle = Math.PI;
        #mode;
        get mouse_over() {
            const { x: local_mouse_x , y: local_mouse_y  } = this.canvas_to_local_position(mouseX, mouseY);
            const { x , y , width , height , start_angle , stop_angle  } = this;
            console.assert(width === height, "mouse_over currently only works for arc's with equal width and height.");
            const arcRadius = width / 2;
            const arcAngle = stop_angle - start_angle;
            const arcRotation = start_angle + arcAngle / 2;
            return this.collide.point_arc(local_mouse_x, local_mouse_y, x, y, arcRadius, arcRotation, arcAngle);
        }
        /**
     * Angle to start the arc. Units are radians by default but may be changed
     * to degrees with the degree_mode property.
     * @type {number}
     */ get start_angle() {
            return this.#start_angle;
        }
        set start_angle(val) {
            this.#start_angle = val;
        }
        /**
     * Angle to stop the arc. Units are radians by default but may be changed
     * to degrees with the degree_mode property.
     * @type {number}
     */ get stop_angle() {
            return this.#stop_angle;
        }
        set stop_angle(val) {
            this.#stop_angle = val;
        }
        /**
     * determines the way of drawing the arc:
     * - OPEN - like an open semi-circle
     * - CHORD - closed semi-circle
     * - PIE - closed pie segment
     * @type {CHORD|PIE|OPEN}
     */ get mode() {
            return this.#mode;
        }
        set mode(val) {
            this.#mode = val;
        }
    };
/**
 * Draws an arc to the screen.
 * The origin may be changed with the ellipse_mode property.
 *
 * The arc is always drawn clockwise from wherever start falls to wherever
 * stop falls on the ellipse. Adding or subtracting TWO_PI to either angle
 * does not change where they fall. If both start and stop fall at the same
 * place, a full ellipse will be drawn. Be aware that the y-axis increases in
 * the downward direction, therefore angles are measured clockwise from the
 * positive x-direction ("3 o'clock").
 * @element arc
 */ class Arc extends (0, _shapeProps.addXY)((0, _shapeProps.addWidthHeight)(addArcProps(add2DFillStroke(Transformed2DElement)))) {
    static overloads = [
        "x, y, width, height, start_angle, stop_angle, [mode]"
    ];
}
customElements.define("p-arc", Arc);
const addEllipse2DCollisionProps = (baseClass)=>class extends baseClass {
        collider = (0, _collideMethods.collider_type).ellipse;
        get collision_args() {
            const { x , y  } = this.local_to_canvas_position(this.x, this.y);
            const { pixel_density  } = this.canvas;
            const { w  } = this.width * pixel_density;
            const { h  } = this.height * pixel_density || w;
            return [
                x,
                y,
                w,
                h
            ];
        }
        get mouse_over() {
            const { x: local_mouse_x , y: local_mouse_y  } = this.canvas_to_local_position(mouseX, mouseY);
            const { x , y , width , height  } = this.this_element;
            return this.collide.point_ellipse(local_mouse_x, local_mouse_y, x, y, width, height);
        }
    };
/**
 * Draws an ellipse (oval) to a 3D canvas. If no height is specified, the
 * value of width is used for both the width and height. If a
 * negative height or width is specified, the absolute value is taken.
 *
 * An ellipse with equal width and height is a circle. The origin may be
 * changed with the ellipseMode() function.
 * @element ellipse
 */ class Ellipse extends (0, _shapeProps.addXY)((0, _shapeProps.addWidthHeight)((0, _colorProps.addFillStroke)(addEllipse2DCollisionProps(Transformed2DElement)))) {
    static overloads = [
        "x, y, width, [height]"
    ];
}
customElements.define("p-ellipse", Ellipse);
const addCircle2DCollisionProps = (baseClass)=>class extends baseClass {
        constructor(){
            super([
                "x, y, d"
            ]);
        }
        collider = (0, _collideMethods.collider_type).circle;
        get collision_args() {
            const { x , y  } = this.local_to_canvas_position(this.x, this.y);
            const d = this.this_element.d * this.pInst.pow(this.canvas.pixel_density, 2);
            return [
                x,
                y,
                d
            ];
        }
        get mouse_over() {
            const { mouseX: mouseX1 , mouseY: mouseY1  } = this.pInst;
            const { x: local_mouse_x , y: local_mouse_y  } = this.canvas_to_local_position(mouseX1, mouseY1);
            const { x , y , diameter  } = this;
            return this.collide.point_circle(local_mouse_x, local_mouse_y, x, y, diameter);
        }
    };
const addDiameter = (baseClass)=>class extends baseClass {
        #diameter = 100;
        get diameter() {
            return this.#diameter;
        }
        set diameter(val) {
            this.#diameter = val;
        }
    };
/**
 * Draws a circle to the screen. A circle is a simple closed shape. It is the
 * set of all points in a plane that are at a given distance from a given
 * point, the center.
 * @element circle
 */ class Circle extends (0, _shapeProps.addXY)(addDiameter(add2DFillStroke(addCircle2DCollisionProps(Transformed2DElement)))) {
    static overloads = [
        "x, y, diameter"
    ];
}
customElements.define("p-circle", Circle);
const addLine2DCollisionProps = (baseClass)=>class extends baseClass {
        collider = (0, _collideMethods.collider_type).line;
        get collision_args() {
            const { x: x1 , y: y1  } = this.local_to_canvas_position(this.x1, this.y1);
            const { x: x2 , y: y2  } = this.local_to_canvas_position(this.x2, this.y2);
            return [
                x1,
                y1,
                x2,
                y2
            ];
        }
        get mouse_over() {
            const { x: local_mouse_x , y: local_mouse_y  } = this.canvas_to_local_position(mouseX, mouseY);
            const { x1 , y1 , x2 , y2  } = this;
            return this.collide.point_line(local_mouse_x, local_mouse_y, x1, y1, x2, y2);
        }
    };
/**
 * Draws a line (a direct path between two points) to the screen. Its width
 * can be modified by using the stroke_weight property. A line cannot be
 * filled, therefore the fill_color property will not affect the color of a
 * line. So to color a line, use the stroke property.
 * @element line
 */ class Line extends (0, _shapeProps.addXY12)(add2DStroke(addLine2DCollisionProps(Transformed2DElement))) {
    static overloads = [
        "x1, y1, x2, y2"
    ];
}
customElements.define("p-line", Line);
const addPointCollisionProps = (baseClass)=>class extends baseClass {
        collider = (0, _collideMethods.collider_type).circle;
        get collision_args() {
            const { x , y  } = this.local_to_canvas_position(this.x, this.y);
            const { stroke_weight  } = this;
            const { pixel_density  } = this.canvas;
            const d = stroke_weight * this.pInst.pow(pixel_density, 2);
            return [
                x,
                y,
                d
            ];
        }
        get mouse_over() {
            const { x , y , stroke_weight  } = this;
            const { pixel_density  } = this.canvas;
            const { x: local_mouse_x , y: local_mouse_y  } = this.canvas_to_local_position(this.pInst.mouseX, this.pInst.mouseY);
            const d = stroke_weight * this.pInst.pow(pixel_density, 2);
            return this.collide.point_circle(local_mouse_x, local_mouse_y, x, y, d);
        }
    };
/**
 * Draws a point, a coordinate in space at the dimension of one pixel. The
 * color of the point is changed with the stroke property. The size of
 * the point can be changed with the stroke_weight property.
 * @element point
 */ class Point extends (0, _shapeProps.addXY)(add2DStroke(addPointCollisionProps(Transformed2DElement))) {
    static overloads = [
        "x, y"
    ];
}
customElements.define("p-point", Point);
const addQuad2DCollisionProps = (baseClass)=>class extends baseClass {
        collider = (0, _collideMethods.collider_type).poly;
        get collision_args() {
            return [
                this.vertices.map(transformVertexFn(this))
            ];
        }
        get mouse_over() {
            const { x: local_mouse_x , y: local_mouse_y  } = this.canvas_to_local_position(this.pInst.mouseX, this.pInst.mouseY);
            return this.collide.point_poly(local_mouse_x, local_mouse_y, this.vertices);
        }
        get vertices() {
            const { x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4  } = this;
            return [
                this.pInst.createVector(x1, y1),
                this.pInst.createVector(x2, y2),
                this.pInst.createVector(x3, y3),
                this.pInst.createVector(x4, y4), 
            ];
        }
    };
/**
 * Draws a quad on the canvas. A quad is a quadrilateral, a four-sided
 * polygon. It is similar to a rectangle, but the angles between its edges
 * are not constrained to ninety degrees. The x1 and y1 properties set the
 * first vertex and the subsequent pairs should proceed clockwise or
 * counter-clockwise around the defined shape.
 * @element quad
 */ class Quad extends (0, _shapeProps.addXY12)((0, _shapeProps.addXY3)((0, _shapeProps.addXY4)(add2DFillStroke(addQuad2DCollisionProps(Transformed2DElement))))) {
    static overloads = [
        "x1, y1, x2, y2, x3, y3, x4, y4"
    ];
}
customElements.define("p-quad", Quad);
const addCornerRadius = (baseClass)=>class extends baseClass {
        #top_left_radius = 0;
        #top_right_radius = 0;
        #bottom_left_radius = 0;
        #bottom_right_radius = 0;
        /**
     * radius of top-left corner
     * @type {number}
     */ get top_left_radius() {
            return this.#top_left_radius;
        }
        set top_left_radius(val) {
            this.#top_left_radius = val;
        }
        /**
     * radius of top-right corner
     * @type {number}
     */ get top_right_radius() {
            return this.#top_right_radius;
        }
        set top_right_radius(val) {
            this.#top_right_radius = val;
        }
        /**
     * radius of bottom-left corner
     * @type {number}
     */ get bottom_left_radius() {
            return this.#bottom_left_radius;
        }
        set bottom_left_radius(val) {
            this.#bottom_left_radius = val;
        }
        /**
     * radius of bottom-right corner
     * @type {number}
     */ get bottom_right_radius() {
            return this.#bottom_right_radius;
        }
        set bottom_right_radius(val) {
            this.#bottom_right_radius = val;
        }
    };
/**
 * Draws a rectangle on the canvas. A rectangle is a four-sided closed shape
 * with every angle at ninety degrees. By default, the x and y properties
 * set the location of the upper-left corner, w sets the width, and h sets
 * the height. The way these properties are interpreted may be changed with
 * the rect_mode property.
 * @element rect
 */ class Rect extends (0, _shapeProps.addXY)((0, _shapeProps.addWidthHeight)((0, _shapeProps.addRectMode)(addCornerRadius(add2DFillStroke(Transformed2DElement))))) {
    static overloads = [
        "x, y, width, height, top_left_radius, top_right_radius, bottom_right_radius, bottom_left_radius", 
    ];
    collider = (0, _collideMethods.collider_type).rect;
    get collision_args() {
        const { x , y  } = this.local_to_canvas_position(this.x, this.y);
        const { pixel_density  } = this.canvas;
        const w = this.width * this.pInst.pow(pixel_density, 2);
        const h = this.height * this.pInst.pow(pixel_density, 2);
        return [
            x,
            y,
            w,
            h
        ];
    }
    get mouse_over() {
        const { x: local_mouse_x , y: local_mouse_y  } = this.canvas_to_local_position(this.pInst.mouseX, this.pInst.mouseY);
        const { x , y , width , height  } = this;
        return this.collide.point_rect(local_mouse_x, local_mouse_y, x, y, width, height);
    }
}
customElements.define("p-rect", Rect);
/**
 * Draws a square to the screen. A square is a four-sided shape with every
 * angle at ninety degrees, and equal side size. This element is a special
 * case of the rect element, where the width and height are the same, and the
 * attribute is called "s" for side size. By default, the x and y attributes
 * set the location of the upper-left corner, and s sets the side size of the
 * square. The way these attributes are interpreted, may be changed with the
 * rect_mode attribute.
 *
 * The tl, tr, br, and bl attributes, if specified, determine corner radius
 * for the top-left, top-right, lower-right and lower-left corners,
 * respectively. An omitted corner radius attribute is set to the value of
 * the previously specified radius value in the attribute list.
 *
 * @element square
 */ class Square extends (0, _shapeProps.addXY)((0, _shapeProps.addRectMode)(addCornerRadius(add2DFillStroke(Transformed2DElement)))) {
    #size = 100;
    static overloads = [
        "x, y, size, top_left_radius, top_right_radius, bottom_right_radius, bottom_left_radius", 
    ];
    collider = (0, _collideMethods.collider_type).rect;
    get collision_args() {
        const { x , y  } = this.local_to_canvas_position(this.x, this.y);
        const { pixel_density  } = this.canvas;
        const { size  } = this;
        const w = size * this.pInst.pow(pixel_density, 2);
        const h = w;
        return [
            x,
            y,
            w,
            h
        ];
    }
    get mouse_over() {
        const { x: local_mouse_x , y: local_mouse_y  } = this.canvas_to_local_position(this.pInst.mouseX, this.pInst.mouseY);
        const { x , y , size  } = this;
        return this.collide.point_rect(local_mouse_x, local_mouse_y, x, y, size, size);
    }
    /**
   * The side size of the square
   * @type {number}
   */ get size() {
        return this.#size;
    }
    set size(val) {
        if (!isNaN(val)) this.#size = Number(val);
        else console.error(`${this.tagName}'s size is being set to ${val}, but it may only be set to a number.`);
    }
}
customElements.define("p-square", Square);
/**
 * Draws a triangle to the canvas. A triangle is a plane created by connecting
 * three points. x1 and y1 specify the first point, x2 and y2 specify the
 * second point, and x3 and y3 specify the
 * third point.
 * @element triangle
 */ class Triangle extends (0, _shapeProps.addXY12)((0, _shapeProps.addXY3)(add2DFillStroke(Transformed2DElement))) {
    static overloads = [
        "x1, y1, x2, y2, x3, y3"
    ];
    collider = (0, _collideMethods.collider_type).poly;
    get collision_args() {
        return [
            this.vertices.map(transformVertexFn(this))
        ];
    }
    get mouse_over() {
        const { x: local_mouse_x , y: local_mouse_y  } = this.canvas_to_local_position(this.pInst.mouseX, this.pInst.mouseY);
        const { x1 , y1 , x2 , y2 , x3 , y3  } = this;
        return this.collide.point_triangle(local_mouse_x, local_mouse_y, x1, y1, x2, y2, x3, y3);
    }
    get vertices() {
        const { x1 , y1 , x2 , y2 , x3 , y3  } = this;
        return [
            this.pInst.createVector(x1, y1),
            this.pInst.createVector(x2, y2),
            this.pInst.createVector(x3, y3), 
        ];
    }
}
customElements.define("p-triangle", Triangle);
/**
 * Draws a cubic Bezier curve on the screen. These curves are defined by a
 * series of anchor and control points. x1 and y1 specify
 * the first anchor point and x4 and y4 specify the other
 * anchor point, which become the first and last points on the curve. (x2, y2)
 * and (x3, y3) specify the two control points which define the shape
 * of the curve. Approximately speaking, control points "pull" the curve
 * towards them.
 *
 * Bezier curves were developed by French automotive engineer Pierre Bezier,
 * and are commonly used in computer graphics to define gently sloping curves.
 * @element bezier
 */ class Bezier extends (0, _shapeProps.addXY12)((0, _shapeProps.addXY3)((0, _shapeProps.addXY4)(add2DFillStroke((0, _shapeMethods.addBezierMethods)((0, _core.RenderedElement)))))) {
    static overloads = [
        "x1, y1, x2, y2, x3, y3, x4, y4"
    ];
}
customElements.define("p-bezier", Bezier);
/**
 * Draws a curved line on the screen between two points, given as (x2, y2) and (x3, y3).
 * (x1, y1) is a control point, as
 * if the curve came from this point even though it's not drawn. (x4, y4) similarly describes
 * the other control point.
 *
 * Longer curves can be created by putting a series of ```<curve>``` elements
 * together or using ```<curve-vertex>```. The curve_tightness property provides control
 * for the visual quality of the curve.
 * The ```<curve>``` element is an implementation of Catmull-Rom splines.
 * @element curve
 */ class Curve extends (0, _shapeProps.addXY12)((0, _shapeProps.addXY3)((0, _shapeProps.addXY4)((0, _shapeProps.addCurveTightness)(add2DFillStroke((0, _shapeMethods.addCurveMethods)(Transformed2DElement)))))) {
    static overloads = [
        "x1, y1, x2, y2, x3, y3, x4, y4"
    ];
}
customElements.define("p-curve", Curve);
/**
 * Use the ```<contour>``` element to create negative shapes
 * within a ```<shape>``` element such as the center of the letter 'O'.
 * The vertices of the ```<contour>``` are defined by its
 * ```<vertex>``` and ```<curve-vertex>``` children.
 * The vertices that define a negative shape must "wind" in the opposite direction
 * from the exterior shape. First draw vertices for the exterior clockwise order, then for internal shapes, draw vertices
 * shape in counter-clockwise.
 *
 * This element must be a child of a ```<shape>```.
 * @element contour
 * @example Rectangular cut out
 * ```html
 * <canvas
 *    width="400"
 *    height="400"
 *    background="120, 140, 80"
 *    loop="false"
 * >
 *  <shape
 *      anchor="width/2, height/2"
 *      mode="CLOSE"
 *      fill="240, 200, 180"
 *      stroke="200, 100, 60"
 *      stroke_weight="4"
 *  >
 *    <vertex x="-100" y="-100">
 *      <vertex x="100">
 *        <vertex y="100">
 *          <vertex x="-100" />
 *        </vertex>
 *      </vertex>
 *    </vertex>
 *    <contour>
 *      <vertex x="-50" y="-50">
 *        <vertex y="50">
 *          <vertex x="50">
 *            <vertex y="-50" />
 *          </vertex>
 *        </vertex>
 *      </vertex>
 *    </contour>
 *  </shape>
 * </canvas>
 * ```
 */ class Contour extends add2DFillStroke((0, _core.RenderedElement)) {
    renderFunctionName = "beginContour";
    endRender() {
        this.pInst.endContour();
    }
}
customElements.define("p-contour", Contour);
const addShape2DCollisionProps = (baseClass)=>class extends baseClass {
        collider = (0, _collideMethods.collider_type).poly;
        get collision_args() {
            return [
                this.vertices.map(transformVertexFn(this))
            ];
        }
        get vertices() {
            const arrayFromChildren = (el)=>{
                const ca = Array.from(el.children);
                return ca.concat(ca.map(arrayFromChildren)).flat();
            };
            const childArray = arrayFromChildren(this);
            const vertexChildren = childArray.filter((el)=>el instanceof Vertex && el.this_element);
            const vertices = vertexChildren.map((el)=>{
                if (el instanceof QuadraticVertex) {
                    const { x3 , y3  } = el;
                    return this.pInst.createVector(x3, y3);
                }
                const { x , y  } = el;
                return this.pInst.createVector(x, y);
            });
            return vertices.concat(vertices.slice(0));
        }
    };
const addShapeElementProps = (baseClass)=>class extends baseClass {
        #kind;
        renderFunctionName = "beginShape";
        static overloads = [
            "[kind]"
        ];
        endRender(assigned) {
            if (assigned.hasOwnProperty("mode")) this.pInst.endShape(assigned.mode);
            else this.pInst.endShape();
        }
        /**
     * The options available for kind are
     *
     * POINTS
     * Draw a series of points
     *
     * LINES
     * Draw a series of unconnected line segments (individual lines)
     *
     * TRIANGLES
     * Draw a series of separate triangles
     *
     * TRIANGLE_FAN
     * Draw a series of connected triangles sharing the first vertex in a fan-like fashion
     *
     * TRIANGLE_STRIP
     * Draw a series of connected triangles in strip fashion
     *
     * QUADS
     * Draw a series of separate quads
     *
     * QUAD_STRIP
     * Draw quad strip using adjacent edges to form the next quad
     *
     * TESS (WEBGL only)
     * Handle irregular polygon for filling curve by explicit tessellation
     * @type {POINTS|LINES|TRIANGLES|TRIANGLE_FAN TRIANGLE_STRIP|QUADS|QUAD_STRIP|TESS}
     */ get kind() {
            return this.#kind;
        }
        set kind(val) {
            this.#kind = val;
        }
    };
/**
 * Using the ```<shape>``` element allow creating more
 * complex forms. The vertices of the shape are defined by its ```<vertex>```,
 * ```<curve-vertex>```, and/or ```<quadratic-vertex>``` children.
 * The value of the kind property tells it which
 * types of shapes to create from the provided vertices. With no mode
 * specified, the shape can be any irregular polygon.
 *
 * Transformations such as translate, angle, and scale do not work on children on ```<shape>```.
 * It is also not possible to use other shapes, such as
 * ```<ellipse>``` or ```<rect>``` as children of ```<shape>```.
 * @element shape
 */ class Shape extends addShapeElementProps(add2DFillStroke(addShape2DCollisionProps(Transformed2DElement))) {
}
customElements.define("p-shape", Shape);
/**
 * All shapes are constructed by connecting a series of vertices. ```<vertex>```
 * is used to specify the vertex coordinates for points, lines, triangles,
 * quads, and polygons. It is used exclusively as a child of the ```<shape>``` element.
 * @element vertex
 */ class Vertex extends (0, _shapeProps.addXY)((0, _core.RenderedElement)) {
    static overloads = [
        "x, y"
    ];
}
customElements.define("p-vertex", Vertex);
/**
 * Specifies vertex coordinates for quadratic Bezier curves. Each ```<quadratic-vertex>```
 * defines the position of one control points and one
 * anchor point of a Bezier curve, adding a new segment to a line or shape.
 * The first ```<quadratic-vertex>``` child of a ```<shape>``` element
 * must have a ```<vertex>``` sibling above it to set the first anchor point.
 *
 * This element must be a child of a ```<shape>``` element
 * and only when there is no MODE or POINTS property specified on the
 *  ```<shape>```.
 */ class QuadraticVertex extends (0, _shapeProps.addCXY)((0, _shapeProps.addXY3)((0, _core.RenderedElement))) {
    static overloads = [
        "cx, cy, x3, y3"
    ];
}
customElements.define("p-quadratic-vertex", QuadraticVertex);
/**
 * Specifies vertex coordinates for curves. This function may only
 * be used as a child of the ```<shape>``` element and only when there
 * is no MODE property specified on the ```<shape>``.
 *
 * The first and last points in a series of ```<curve-vertex>``` lines
 * will be used to
 * guide the beginning and end of the curve. A minimum of four
 * points is required to draw a tiny curve between the second and
 * third points. Adding a fifth point with ```<curve-vertex>``` will draw
 * the curve between the second, third, and fourth points. The
 * ```<curve-vertex>``` element is an implementation of Catmull-Rom
 * splines.
 */ class CurveVertex extends (0, _shapeProps.addXYZ)((0, _shapeProps.addCurveTightness)((0, _core.RenderedElement))) {
    static overloads = [
        "x, y"
    ];
}
customElements.define("p-curve-vertex", CurveVertex);

},{"../core":"cTP0J","../properties/color_props":"8V5jU","../properties/shape_props":"4WDTj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT","../methods/shape_methods":"gkECc","../methods/collide_methods":"jqqRG","../properties/transform_props":"iZSkq","../methods/transform_methods":"8Bjut"}],"4WDTj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addWidthHeight", ()=>addWidthHeight);
parcelHelpers.export(exports, "addXY", ()=>addXY);
parcelHelpers.export(exports, "addXYZ", ()=>addXYZ);
parcelHelpers.export(exports, "addXY12", ()=>addXY12);
parcelHelpers.export(exports, "addXY3", ()=>addXY3);
parcelHelpers.export(exports, "addXYZ1", ()=>addXYZ1);
parcelHelpers.export(exports, "addXYZ2", ()=>addXYZ2);
parcelHelpers.export(exports, "addXY4", ()=>addXY4);
parcelHelpers.export(exports, "addZ3", ()=>addZ3);
parcelHelpers.export(exports, "addXYZ3", ()=>addXYZ3);
parcelHelpers.export(exports, "addXYZ123", ()=>addXYZ123);
parcelHelpers.export(exports, "addZ4", ()=>addZ4);
parcelHelpers.export(exports, "addXYZ4", ()=>addXYZ4);
parcelHelpers.export(exports, "addRectMode", ()=>addRectMode);
parcelHelpers.export(exports, "add2DStrokeStyling", ()=>add2DStrokeStyling);
parcelHelpers.export(exports, "addCurveTightness", ()=>addCurveTightness);
parcelHelpers.export(exports, "addCXY", ()=>addCXY);
parcelHelpers.export(exports, "addCXYZ", ()=>addCXYZ);
const addWidthHeight = (baseClass)=>class extends baseClass {
        #width;
        #height;
        /**
     * The width of the element in pixels.
     * @type {number}
     */ get width() {
            return this.#width;
        }
        set width(val) {
            if (!isNaN(val)) this.#width = Number(val);
            else console.error(`${this.tagName}'s width is being set to ${val}, but it may only be set to a number.`);
        }
        /**
     * The height of the element in pixels.
     * @type {number}
     */ get height() {
            return this.#height;
        }
        set height(val) {
            if (!isNaN(val)) this.#height = Number(val);
            else console.error(`${this.tagName}'s height is being set to ${val}, but it may only be set to a number.`);
        }
    };
const addXY = (baseClass)=>class extends baseClass {
        #x;
        #y;
        /**
     * The x-coordinate of the element relative to the current anchor.
     * @type {number}
     */ get x() {
            return this.#x;
        }
        set x(val) {
            if (!isNaN(val)) this.#x = Number(val);
            else console.error(`${this.tagName}'s x property is being set to ${val}, but it may only be set to a number`);
        }
        /**
     * The y-coordinate of the element relative to the current anchor.
     * @type {number}
     */ get y() {
            return this.#y;
        }
        set y(val) {
            if (!isNaN(val)) this.#y = Number(val);
            else console.error(`${this.tagName}'s y property is being set to ${val}, but it may only be set to a number`);
        }
    };
const addZ = (baseClass)=>class extends baseClass {
        #z;
        /**
     * The z-coordinate of the element relative to the current anchor.
     * @type {number}
     */ get z() {
            return this.#z;
        }
        set z(val) {
            if (!isNaN(val)) this.#z = Number(val);
            else console.error(`${this.tagName}'s z property is being set to ${val}, but it may only be set to a number`);
        }
    };
const addXYZ = (baseClass)=>class extends addXY(addZ(baseClass)) {
    };
const addXY1 = (baseClass)=>class extends baseClass {
        #x1;
        #y1;
        /**
     * The first x-coordinate of the element relative to the current anchor.
     * @type {number}
     */ get x1() {
            return this.#x1;
        }
        set x1(val) {
            if (!isNaN(val)) this.#x1 = val;
            else console.error(`${this.tagName}'s x1 is being set to ${val}, but it may only be set to a number.`);
        }
        /**
     * The first y-coordinate of the element relative to the current anchor.
     * @type {number}
     */ get y1() {
            return this.#y1;
        }
        set y1(val) {
            if (!isNaN(val)) this.#y1 = val;
            else console.error(`${this.tagName}'s y1 is being set to ${val}, but it may only be set to a number.`);
        }
    };
const addXY2 = (baseClass)=>class extends baseClass {
        #x2;
        #y2;
        /**
     * The second x-coordinate of the element relative to the current anchor.
     * @type {number}
     */ get x2() {
            return this.#x2;
        }
        set x2(val) {
            if (!isNaN(val)) this.#x2 = val;
            else console.error(`${this.tagName}'s x2 is being set to ${val}, but it may only be set to a number.`);
        }
        /**
     * The second y-coordinate of the element relative to the current anchor.
     * @type {number}
     */ get y2() {
            return this.#y2;
        }
        set y2(val) {
            if (!isNaN(val)) this.#y2 = val;
            else console.error(`${this.tagName}'s y2 is being set to ${val}, but it may only be set to a number.`);
        }
    };
const addXY12 = (baseClass)=>class extends addXY1(addXY2(baseClass)) {
    };
const addXY3 = (baseClass)=>class extends baseClass {
        #x3;
        #y3;
        /**
     * The third x-coordinate of the element relative to the current anchor.
     * @type {number}
     */ get x3() {
            return this.#x3;
        }
        set x3(val) {
            if (!isNaN(val)) this.#x3 = val;
            else console.error(`${this.tagName}'s x3 is being set to ${val}, but it may only be set to a number.`);
        }
        /**
     * The third y-coordinate of the element relative to the current anchor.
     * @type {number}
     */ get y3() {
            return this.#y3;
        }
        set y3(val) {
            if (!isNaN(val)) this.#y3 = val;
            else console.error(`${this.tagName}'s y3 is being set to ${val}, but it may only be set to a number.`);
        }
    };
const addXY123 = (baseClass)=>class extends addXY12(addXY3(baseClass)) {
    };
const addZ1 = (baseClass)=>class extends baseClass {
        #z1;
        /**
     * The first z-coordinate of the element relative to the current anchor. |
     * @type {number}
     */ get z1() {
            return this.#z1;
        }
        set z1(val) {
            if (!isNaN(val)) this.#z1 = val;
            else console.error(`${this.tagName}'s z1 is being set to ${val}, but it may only be set to a number.`);
        }
    };
const addXYZ1 = (baseClass)=>class extends addXY1(addZ1(baseClass)) {
    };
const addZ2 = (baseClass)=>class extends baseClass {
        #z2;
        /**
     * The second z-coordinate of the element relative to the current anchor. |
     * @type {number}
     */ get z2() {
            return this.#z2;
        }
        set z2(val) {
            if (!isNaN(val)) this.#z2 = val;
            else console.error(`${this.tagName}'s z2 is being set to ${val}, but it may only be set to a number.`);
        }
    };
const addXYZ2 = (baseClass)=>class extends addXY2(addZ2(baseClass)) {
    };
const addXYZ12 = (baseClass)=>class extends addXYZ1(addXYZ2(baseClass)) {
    };
const addXY4 = (baseClass)=>class extends addXY123(baseClass) {
        #x4;
        #y4;
        /**
     * The fourth x-coordinate of the element relative to the current anchor.
     * @type {number}
     */ get x4() {
            return this.#x4;
        }
        set x4(val) {
            if (!isNaN(val)) this.#x4 = val;
            else console.error(`${this.tagName}'s x4 is being set to ${val}, but it may only be set to a number.`);
        }
        /**
     * The fourth y-coordinate of the element relative to the current anchor.
     * @type {number}
     */ get y4() {
            return this.#y4;
        }
        set y4(val) {
            if (!isNaN(val)) this.#y4 = val;
            else console.error(`${this.tagName}'s y4 is being set to ${val}, but it may only be set to a number.`);
        }
    };
const addZ3 = (baseClass)=>class extends baseClass {
        #z3;
        /**
     * The third z-coordinate of the element relative to the current anchor. |
     * @type {number}
     */ get z3() {
            return this.#z3;
        }
        set z3(val) {
            if (!isNaN(val)) this.#z3 = val;
            else console.error(`${this.tagName}'s z3 is being set to ${val}, but it may only be set to a number.`);
        }
    };
const addXYZ3 = (baseClass)=>class extends addXY3(addZ3(baseClass)) {
    };
const addXYZ123 = (baseClass)=>class extends addXYZ12(addXY3(addZ3(baseClass))) {
    };
const addZ4 = (baseClass)=>class extends baseClass {
        #z4;
        /**
     * The fourth z-coordinate of the element relative to the current anchor. |
     * @type {number}
     */ get z4() {
            return this.#z4;
        }
        set z4(val) {
            if (!isNaN(val)) this.#z4 = val;
            else console.error(`${this.tagName}'s z4 is being set to ${val}, but it may only be set to a number.`);
        }
    };
const addXYZ4 = (baseClass)=>class extends addXY4(addZ4(baseClass)) {
    };
const addRectMode = (baseClass)=>class extends baseClass {
        #rect_mode;
        /**
     * Modifies the location from which rectangles are drawn by changing the way
     * in which x and y coordinates are interpreted.
     *
     * The default mode is CORNER, which interprets the x and y as the
     * upper-left corner of the shape.
     *
     * rect_mode="CORNERS" interprets x and y as the location of
     * one of the corners, and width and height as the location of
     * the diagonally opposite corner. Note, the rectangle is drawn between the
     * coordinates, so it is not necessary that the first corner be the upper left
     * corner.
     *
     * rect_mode="CENTER" interprets x and y as the shape's center
     * point.
     *
     * rect_mode="RADIUS" also uses x and y as the shape's
     * center
     * point, but uses width and height to specify half of the shape's
     * width and height respectively.
     *
     * The value to this property must be written in ALL CAPS because they are
     * predefined as constants in ALL CAPS.
     *
     * @type {CORNER|CORNERS|CENTER|RADIUS}
     */ get rect_mode() {
            return this.#rect_mode;
        }
        set rect_mode(mode) {
            this.pInst.rectMode(mode);
            this.#rect_mode = this.pInst._renderer._rectMode;
        }
    };
const add2DStrokeStyling = (baseClass)=>class extends baseClass {
        #smooth = true;
        #stroke_cap = "round";
        #stroke_join = "miter";
        /**
     * smooth="true" draws all geometry with smooth (anti-aliased) edges. smooth="true" will also
     * improve image quality of resized images. smooth is true by
     * default on a 2D canvas. smooth="false" can be used to disable smoothing of geometry,
     * images, and fonts.
     * @type {boolean}
     */ get smooth() {
            return this.#smooth;
        }
        set smooth(val) {
            if (typeof val !== "boolean") return console.error(`${this.tagName}'s smooth property is being set to ${val}, but it may only be set to true or false.`);
            if (val) this.pInst.smooth();
            else this.pInst.noSmooth();
            this.#smooth = val;
        }
        /**
     * Sets the style for rendering line endings. These ends are either rounded,
     * squared or extended, each of which specified with the corresponding
     * parameters: ROUND, SQUARE and PROJECT. The default cap is ROUND.
     *
     * The value on this property must be written in ALL CAPS because they are
     * predefined as constants in ALL CAPS.
     * @type {ROUND|SQUARE|PROJECT}
     */ get stroke_cap() {
            return this.#stroke_cap;
        }
        set stroke_cap(val) {
            this.pInst.strokeCap(val);
            this.#stroke_cap = this.pInst.drawingContext.lineCap;
        }
        /**
     * Sets the style of the joints which connect line segments. These joints
     * are either mitered, beveled or rounded and specified with the
     * corresponding parameters MITER, BEVEL and ROUND. The default joint is
     * MITER.
     *
     * The parameter to this method must be written in ALL CAPS because they are
     * predefined as constants in ALL CAPS.
     * @type {MITER|BEVEL|ROUND}
     */ get stroke_join() {
            return this.#stroke_join;
        }
        set stroke_join(val) {
            this.pInst.strokeJoin(val);
            this.#stroke_join = this.pInst.drawingContext.lineJoin;
        }
    };
const addCurveTightness = (baseClass)=>class extends baseClass {
        #tightness = 0;
        /**
     * Modifies the quality of the curve. The amount
     * determines how the curve fits to the vertex points. The value 0.0 is the
     * default value (this value defines the curves to be Catmull-Rom
     * splines) and the value 1.0 connects all the points with straight lines.
     * Values within the range -5.0 and 5.0 will deform the curves but will leave
     * them recognizable and as values increase in magnitude, they will continue to deform.
     * @type {number}
     */ get tightness() {
            return this.#tightness;
        }
        set tightness(val) {
            this.#tightness = val;
        }
    };
const addCXY = (baseClass)=>class extends baseClass {
        #cx;
        #cy;
        get cx() {
            return this.#cx;
        }
        set cx(val) {
            this.#cx = val;
        }
        get cy() {
            return this.#cy;
        }
        set cy(val) {
            this.#cy = val;
        }
    };
const addCXYZ = (baseClass)=>class extends baseClass {
        #cz;
        get cz() {
            return this.#cz;
        }
        set cz(val) {
            this.#cz = val;
        }
    };

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gkECc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addBezierMethods", ()=>addBezierMethods);
parcelHelpers.export(exports, "addCurveMethods", ()=>addCurveMethods);
const addBezierMethods = (baseClass)=>class extends baseClass {
        /**
     * Evaluates the position on the bezier at t. t is the
     * resultant point which is given between 0 (start of Bezier) and 1 (end of Bezier).
     *
     * @param {number} t - value between 0 and 1
     * @returns {p5.Vector} - position on Bezier at t
     */ point_at(t) {
            const x = this.pInst.bezierPoint(this.x1, this.x2, this.x3, this.x4, t);
            const y = this.pInst.bezierPoint(this.y1, this.y2, this.y3, this.y4, t);
            return this.pInst.createVector(x, y);
        }
        /**
     * Evaluates the tangent to the Bezier at position t.
     * t is between 0 (start of Bezier) and 1 (end of Bezier).
     * @param {number} t - value between 0 and 1
     * @returns {p5.Vector} - tangent of Bezier at t
     */ tangent_at(t) {
            const x = this.pInst.bezierTangent(this.x1, this.x2, this.x3, this.x4, t);
            const y = this.pInst.bezierTangent(this.y1, this.y2, this.y3, this.y4, t);
            return this.pInst.createVector(x, y);
        }
    };
const addCurveMethods = (baseClass)=>class extends baseClass {
        /**
     * Evaluates the position on the curve at t.
     * t is between 0 (start of curve) and 1 (end of curve).
     *
     * @param {number} t - value between 0 and 1
     * @returns {p5.Vector} - position on curve at t
     */ point_at(t) {
            const x = this.pInst.curvePoint(this.x1, this.x2, this.x3, this.x4, t);
            const y = this.pInst.curvePoint(this.y1, this.y2, this.y3, this.y4, t);
            return this.pInst.createVector(x, y);
        }
        /**
     * Evaluates the tangent to the curve at t.
     * t is between 0 (start of curve) and 1 (end of curve).
     *
     * @param {number} t - value between 0 and 1
     * @returns {p5.Vector} - tangent of curve at t
     */ tangent_at(t) {
            const x = this.pInst.curveTangent(this.x1, this.x2, this.x3, this.x4, t);
            const y = this.pInst.curveTangent(this.y1, this.y2, this.y3, this.y4, t);
            return this.pInst.createVector(x, y);
        }
    };

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iZSkq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "add2DTransformProps", ()=>add2DTransformProps);
parcelHelpers.export(exports, "add3DTransformProps", ()=>add3DTransformProps);
const addAnchor = (baseClass)=>class extends baseClass {
        #anchor = new p5.Vector();
        /**
     * This element and its children are positioned and transformed relative to
     * the anchor position.
     *
     * Setting anchor to one or more comma-separated numbers will result in the
     * values being passed into create_vector and anchor being set to the
     * resulting vector.
     * @type {p5.Vector}
     */ get anchor() {
            return this.#anchor;
        }
        set anchor(val) {
            const { pInst  } = this;
            if (val instanceof p5.Vector) this.#anchor = val;
            else if (Array.isArray(val)) this.#anchor = pInst.createVector(...val);
            else this.#anchor = createVector(val);
        }
    };
const add2DAngle = (baseClass)=>class extends baseClass {
        #angle = 0;
        /**
     * The angle of rotation for the element and its children. The unit for
     * angles may be set with angle_mode.
     * @type {number}
     */ get angle() {
            return this.#angle;
        }
        set angle(val) {
            this.#angle = val;
        }
    };
const addScale = (baseClass)=>class extends baseClass {
        #scale = new p5.Vector(1, 1, 1);
        /**
     * Increases or decreases the size of an element by expanding or contracting
     * vertices. Objects always scale from their anchor point. Scale values are
     * specified as decimal percentages.
     * For example, the setting scale="2.0" increases the dimension of a
     * shape by 200%.
     *
     * Transformations apply to this element and its children. Children's
     * scale will multiply the effect. For example, setting scale="2.0"
     * and then setting scale="1.5" on the child will cause the child to be 3x
     * its size.
     *
     * Setting this to a comma-separated list of numbers will result in those
     * values being passed into create_vector and the resulting vector being set
     * as the scale. Setting this to a single number will set the scale vector
     * to that value in the x, y, and z direction.
     *  @type {p5.Vector}
     */ get scale() {
            return this.#scale;
        }
        set scale(val) {
            if (val instanceof p5.Vector) this.#scale = val;
            if (Array.isArray(val)) this.#scale = new p5.Vector(...val);
            this.#scale = new p5.Vector(val, val, val);
        }
    };
const addShear = (baseClass)=>class extends baseClass {
        #shear_x = 0;
        #shear_y = 0;
        get shear_x() {
            return this.#shear_x;
        }
        set shear_x(val) {
            this.#shear_x = val;
        }
        get shear_y() {
            return this.#shear_y;
        }
        set shear_y(val) {
            this.#shear_y = val;
        }
    };
const addMatrixProps = (baseClass)=>class extends baseClass {
        #apply_matrix = new DOMMatrix();
        #reset_transform = false;
        /**
     * Multiplies the current matrix by the one specified through the values.
     * This is a powerful operation that can perform the equivalent of translate,
     * scale, shear and rotate all at once. You can learn more about transformation
     * matrices on <a href="https://en.wikipedia.org/wiki/Transformation_matrix">
     * Wikipedia</a>.
     *
     * If set to a comma-separated list of numbers, these number will first be
     * passed into the
     * <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix">
     * DOMMatrix</a> constructor.
     * @type {DOMMatrix}
     */ get apply_transform() {
            return this.#apply_matrix;
        }
        set apply_transform(val) {
            if (val instanceof DOMMatrix) this.#apply_matrix = val;
            else this.#apply_matrix = new DOMMatrix(val);
        }
        /**
     * If set to true, this resets the transformations applied to this element,
     * its children, and the siblings below this element. This overrides
     * transformation properties such as anchor, angle, scale, and shear.
     */ get reset_transform() {
            return this.#reset_transform;
        }
        set reset_transform(val) {
            this.#reset_transform = val;
        }
    };
const add2DTransformProps = (baseClass)=>class extends addAnchor(add2DAngle(addScale(addShear(addMatrixProps(baseClass))))) {
    };
const add3DAngle = (baseClass)=>class extends baseClass {
        #angle_x = 0;
        #angle_y = 0;
        #angle_z = 0;
        /**
     * The angle of rotation along the x-axis for the element and its children.
     * The unit for angles may be set with angle_mode.
     * @type {number}
     */ get angle_x() {
            return this.#angle_x;
        }
        set angle_x(val) {
            this.#angle_x = val;
        }
        /**
     * The angle of rotation along the y-axis for the element and its children.
     * The unit for angles may be set with angle_mode.
     * @type {number}
     */ get angle_y() {
            return this.#angle_y;
        }
        set angle_y(val) {
            this.#angle_y = val;
        }
        /**
     * The angle of rotation along the z-axis for the element and its children.
     * The unit for angles may be set with angle_mode.
     * @type {number}
     */ get angle_z() {
            return this.#angle_z;
        }
        set angle_z(val) {
            this.#angle_z = val;
        }
    };
const add3DTransformProps = (baseClass)=>class extends addAnchor(add3DAngle(addScale(addShear(baseClass)))) {
    };

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8Bjut":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "add2DTransformMethods", ()=>add2DTransformMethods);
parcelHelpers.export(exports, "add3DTransformMethods", ()=>add3DTransformMethods);
const addPositionConverters = (baseClass)=>class extends baseClass {
        /**
     * Converts a position on the canvas to a position in
     * this element's transformed space.
     * @param {p5.Vector} canvas_position
     * @returns {p5.Vector} local_position
     */ canvas_to_local_position(x = 0, y = 0, z = 0) {
            if (arguments[0] instanceof p5.Vector) {
                const { x: vx , y: vy , z: vz  } = arguments[0];
                x = vx;
                y = vy;
                z = vz;
            }
            const canvas_position = new DOMPoint(x, y, z);
            const inverted_matrix = this.transform_matrix.inverse();
            const scaled_matrix = inverted_matrix.scale(1 / this.pInst.pixelDensity());
            const canvas_point = scaled_matrix.transformPoint(canvas_position);
            return this.pInst.createVector(canvas_point.x, canvas_point.y, canvas_point.z);
        }
        /**
     * Converts a position in this element's transformed space to a
     * position on the canvas.
     * @param {p5.Vector} local_position
     * @returns {p5.Vector} canvas_position
     */ local_to_canvas_position(x = 0, y = 0, z = 0) {
            if (arguments[0] instanceof p5.Vector) {
                const { x: vx , y: vy , z: vz  } = arguments[0];
                x = vx;
                y = vy;
                z = vz;
            }
            const local_position = new DOMPoint(x, y, z);
            const scaled_matrix = this.transform_matrix.scale(1 / this.pInst.pixelDensity());
            const local_point = scaled_matrix.transformPoint(local_position);
            return this.pInst.createVector(local_point.x, local_point.y, local_point.z);
        }
    };
const add2DTransformMethods = (baseClass)=>class extends addPositionConverters(baseClass) {
        #transform_matrix = new DOMMatrix();
        /**
     * transform_matrix stores the result of all the transformation
     * properties applied to this element. (read-only)
     * @type {DOMMatrix}
     * @readonly
     */ get transform_matrix() {
            return this.#transform_matrix;
        }
        /**
     * @private
     */ transform() {
            if (this.reset_transform) this.pInst.resetMatrix();
            else {
                const shear_x_rads = this.pInst._toRadians(this.shear_x);
                const shear_y_rads = this.pInst._toRadians(this.shear_y);
                const shear_x_matrix = new DOMMatrix([
                    1,
                    0,
                    Math.tan(shear_x_rads),
                    1,
                    0,
                    0, 
                ]);
                const shear_y_matrix = new DOMMatrix([
                    1,
                    Math.tan(shear_y_rads),
                    0,
                    1,
                    0,
                    0, 
                ]);
                const transform_matrix = new DOMMatrix().translate(this.anchor.x, this.anchor.y).scale(this.scale.x, this.scale.y).rotate(this.angle).multiply(shear_x_matrix).multiply(shear_y_matrix).multiply(this.apply_transform);
                const { a , b , c , d , e , f  } = transform_matrix;
                this.pInst.drawingContext.transform(a, b, c, d, e, f);
            }
            this.#transform_matrix = this.pInst.drawingContext.getTransform();
        }
    };
const add3DTransformMethods = (baseClass)=>class extends addPositionConverters(baseClass) {
        transform() {
            this.pInst.translate(this.anchor.x, this.anchor.y, this.anchor.z);
            this.pInst.scale(this.scale.x, this.scale.y, this.scale.z);
            this.pInst.rotateX(this.angle_x);
            this.pInst.rotateY(this.angle_y);
            this.pInst.rotateZ(this.angle_z);
            this.pInst.shearX(this.shear_x);
            this.pInst.shearY(this.shear_y);
        }
    };

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"63Xw9":[function(require,module,exports) {
var _p5Modifiers = require("../utils/p5Modifiers");
p5.prototype._width = p5.prototype.width;
p5.prototype._height = p5.prototype.height;
p5.prototype._createDescriptionContainer = function() {
    const cnvId = this.canvas.id;
    const descriptionContainer = document.createElement("div");
    descriptionContainer.setAttribute("id", `${cnvId}_Description`);
    descriptionContainer.setAttribute("role", "region");
    descriptionContainer.setAttribute("aria-label", "Canvas Description");
    const p = document.createElement("p");
    p.setAttribute("id", `${cnvId}_fallbackDesc`);
    descriptionContainer.append(p);
    this.canvas.append(descriptionContainer);
    return descriptionContainer;
};
const fallbackDescId = "_fallbackDesc";
(0, _p5Modifiers.wrapMethod)("_describeHTML", (base)=>function(type, text) {
        const cnvId = this.canvas.id;
        const describeId = `#${cnvId}_Description`;
        if (type === "fallback") {
            if (!this.dummyDOM.querySelector(describeId)) {
                const fallback = this._createDescriptionContainer().querySelector(`#${cnvId}_fallbackDesc`);
                fallback.innerHTML = text;
            } else base.call(this, type, text);
            //if the container for the description exists
            this.descriptions.fallback = this.dummyDOM.querySelector(`#${cnvId}${fallbackDescId}`);
            this.descriptions.fallback.innerHTML = text;
        }
    });
(0, _p5Modifiers.wrapMethod)("_describeElementHTML", (base)=>function(type, name, text) {
        const cnvId = this.canvas.id;
        if (type === "fallback" && !this.dummyDOM.querySelector(`#${cnvId}_Description`)) this._createDescriptionContainer();
        base.call(this, type, name, text);
    });
(0, _p5Modifiers.wrapMethod)("_createOutput", (base)=>function(type, display) {
        const cnvId = this.canvas.id;
        if (!this.dummyDOM) this.dummyDOM = document.getElementById(cnvId).parentNode;
        if ((type === "textOutput" || type === "gridOutput") && !this.dummyDOM.querySelector(`#${cnvId}accessibleOutput${display}`)) this._createDescriptionContainer();
        base.call(this, type, display);
    });
p5.prototype.registerMethod("post", function() {
    if (this.text_output || this.grid_output) this._updateAccsOutput();
});
(0, _p5Modifiers.defineProperties)({
    url: {
        get: function() {
            return this.getURL();
        }
    },
    url_path: {
        get: function() {
            return this.getURLPath();
        }
    },
    url_params: {
        get: function() {
            return this.getURLParams();
        }
    },
    log: {
        set: function(val) {
            this.print(val);
        }
    },
    text_output: {
        get: function() {
            return this._accessibleOutputs.text;
        },
        set: function(val) {
            if (val === true) this.textOutput();
            else this.textOutput(val);
        }
    }
});

},{"../utils/p5Modifiers":"kkqqW"}],"4XFJq":[function(require,module,exports) {
var _core = require("../core");
var _colorProps = require("../properties/color_props");
/**
 * Clears the pixels within a buffer. This element only clears the canvas.
 * It will not clear objects created by create_x() functions such as
 * create_video() or create_div().
 * Unlike the main graphics context, pixels in additional graphics areas created
 * with create_graphics() can be entirely
 * or partially transparent. This element clears everything to make all of
 * the pixels 100% transparent.
 *
 * Note: In WebGL mode, this element can have attributes set to normalized RGBA
 * color values in order to clear the screen to a specific color.
 * In addition to color, it will also clear the depth buffer.
 * If you are not using the webGL renderer these color values will have no
 * effect.
 *
 * @element clear
 * @attribute {Number} r normalized red val.
 * @attribute {Number} g normalized green val.
 * @attribute {Number} b normalized blue val.
 * @attribute {Number} a normalized alpha val.
 */ class Clear extends (0, _core.RenderedElement) {
    static overloads = [
        "",
        "r, g, b, a"
    ];
}
customElements.define("p-clear", Clear);
/**
 * The ```<paint-bucket>``` element fills the canvas with a particular color or
 * image.
 *
 * @element paint-bucket
 * @attribute {p5.Color} color  any value created by the <a href="#/p5/color">color
 * @attribute {String} colorstring color string, possible formats include: integer
 *                         rgb() or rgba(), percentage rgb() or rgba(),
 *                         3-digit hex, 6-digit hex
 * @attribute {Number} [a]         opacity of the background relative to current
 *                             color range (default is 0-255)
 * @attribute {Number} gray   specifies a value between white and black
 * @attribute {Number} v1     red or hue value (depending on the current color
 *                        mode)
 * @attribute {Number} v2     green or saturation value (depending on the current
 *                        color mode)
 * @attribute {Number} v3     blue or brightness value (depending on the current
 *                        color mode)
 * @attribute  {Number[]}      values  an array containing the red, green, blue
 *                                 and alpha components of the color
 * @attribute {p5.Image} image    image loaded via an ```<asset>``` (must be
 *                                  same size as the sketch window)
 */ class PaintBucket extends (0, _core.RenderedElement) {
    static overloads = [
        "c",
        "colorstring, [a]",
        "gray, [a]",
        "v1, v2, v3, [a]"
    ];
    renderFunctionName = "background";
}
customElements.define("p-paint-bucket", PaintBucket);

},{"../core":"cTP0J","../properties/color_props":"8V5jU"}],"c8QLH":[function(require,module,exports) {
var _p5Modifiers = require("../utils/p5Modifiers");
(0, _p5Modifiers.defineProperties)({
    animate: {
        get: function() {
            return this.isLooping();
        },
        set: function(val) {
            if (val) this.loop();
            else this.noLoop();
        }
    },
    remove_canvas: {
        get: function() {
            return false;
        },
        set: function() {
            this.remove();
        }
    }
});

},{"../utils/p5Modifiers":"kkqqW"}],"d6HpV":[function(require,module,exports) {
var _p5Modifiers = require("../utils/p5Modifiers");
(0, _p5Modifiers.defineSnakeAlias)("selectAll", "removeElements", "createDiv", "createP", "createSpan", "createImg", "createA", "createSlider", "createButton", "createCheckbox", "createSelect", "createRadio", "createColorPicker", "createInput", "createFileInput", "createVideo", "createAudio", "createCapture", "createElement");

},{"../utils/p5Modifiers":"kkqqW"}],"2CyQw":[function(require,module,exports) {
var _p5Modifiers = require("../utils/p5Modifiers");
(0, _p5Modifiers.defineSnakeAlias)("createCanvas", "createGraphics");

},{"../utils/p5Modifiers":"kkqqW"}],"7BjXm":[function(require,module,exports) {
var _p5Modifiers = require("../utils/p5Modifiers");
(0, _p5Modifiers.defineSnakeAlias)("deviceOrientation", "turnAxis", "keyIsDown");
//  TODO - test on mobile device
p5.prototype.device_moved = false;
//  TODO - test on mobile device
p5.prototype.device_turned = false;
p5.prototype.mouse_down = false;
p5.prototype.mouse_up = false;
p5.prototype.mouse_dragging = false;
p5.prototype.mouse_double_clicked = false;
p5.prototype._mouseWheel = 0;
p5.prototype.key_down = false;
p5.prototype.key_up = false;
//  TODO - test on mobile device
p5.prototype.touch_started = false;
p5.prototype.touch_moved = false;
p5.prototype.touch_ended = false;
p5.prototype._startAngleZ;
(0, _p5Modifiers.wrapMethod)("_handleMotion", (base)=>function() {
        base.call(this);
        this._setProperty("deviced_moved", true);
    });
(0, _p5Modifiers.wrapMethod)("_onmousedown", (base)=>function(e) {
        base.call(this, e);
        this._setProperty("mouse_down", true);
    });
(0, _p5Modifiers.wrapMethod)("_ondbclick", (base)=>function(e) {
        base.call(this, e);
        this._setProperty("mouse_double_clicked", true);
    });
(0, _p5Modifiers.wrapMethod)("_onmousemove", (base)=>function(e) {
        base.call(this, e);
        this._setProperty("mouse_dragging", this.mouseIsPressed);
        this._setProperty("touch_moved", this.mouseIsPressed);
    });
(0, _p5Modifiers.wrapMethod)("_onwheel", (base)=>function(e) {
        base.call(this, e);
        this._setProperty("_mouseWheel", this._mouseWheelDeltaY);
    });
(0, _p5Modifiers.wrapMethod)("_onkeyup", (base)=>function(e) {
        base.call(this, e);
        this._setProperty("key_up", true);
        this._setProperty("key_held", false);
    });
(0, _p5Modifiers.wrapMethod)("_onkeydown", (base)=>function(e) {
        base.call(this, e);
        this._setProperty("key_down", true);
    });
(0, _p5Modifiers.wrapMethod)("_ontouchbase", (base)=>function(e) {
        base.call(this, e);
        this._setProperty("touch_started", true);
    });
(0, _p5Modifiers.wrapMethod)("_ontouchmove", (base)=>function(e) {
        base.call(this, e);
        this._setProperty("touch_moved", true);
    });
(0, _p5Modifiers.wrapMethod)("_ontouchend", (base)=>function(e) {
        base.call(this, e);
        this._setProperty("touch_ended", true);
    });
p5.prototype.registerMethod("pre", function() {
    this._setProperty("mouse_up", this.mouseIsPressed == false && this.mouse_held == true);
    this._setProperty("mouse_held", this.mouseIsPressed);
    this._setProperty("key_held", this.key_down);
});
p5.prototype.registerMethod("post", function() {
    this._setProperty("device_moved", false);
    this._setProperty("mouse_down", false);
    this._setProperty("mouse_dragging", false);
    this._setProperty("mouse_double_clicked", false);
    this._setProperty("_mouseWheel", false);
    this._setProperty("key_up", false);
    this._setProperty("key_down", false);
    this._setProperty("touch_started", false);
    this._setProperty("touch_moved", false);
    this._setProperty("touch_ended", false);
});
//  Create properties with default value
p5.prototype._moveThreshold = 0.5;
p5.prototype._shakeThreshold = 30;
(0, _p5Modifiers.defineProperties)({
    //  TODO - test on mobile device
    device_acceleration: {
        get: function() {
            return this.createVector(this.accelerationX, this.accelerationY, this.accelerationZ);
        }
    },
    //  TODO - test on mobile device
    device_prev_acceleration: {
        get: function() {
            return this.createVector(this.pAccelerationX, this.pAccelerationY, this.pAccelerationZ);
        }
    },
    //  TODO - test on mobile device
    device_rotation: {
        get: function() {
            return this.createVector(this.rotationX, this.rotationY, this.rotationZ);
        }
    },
    //  TODO - test on mobile device
    device_prev_rotation: {
        get: function() {
            return this.createVector(this.pRotationX, this.pRotationY, this.pRotationZ);
        }
    },
    //  TODO - test on mobile device
    device_turned: {
        get: function() {
            if (this.rotationX === null && this.rotationY === null && this.rotationZ === null) return false;
            return this.rotationX !== this.pRotationX || this.rotationY !== this.pRotationY || this.rotationZ !== this.pRotationZ;
        }
    },
    first_frame: {
        get: function() {
            return this.frameCount === 1;
        }
    },
    key_code: {
        get: function() {
            return this.keyCode;
        }
    },
    mouse_button: {
        get: function() {
            return this.mouseButton;
        }
    },
    mouse_pos: {
        get: function() {
            return this.createVector(this.mouseX, this.mouseY);
        }
    },
    mouse_pos_x: {
        get: function() {
            return this.mouseX;
        }
    },
    mouse_pos_y: {
        get: function() {
            return this.mouseY;
        }
    },
    mouse_prev_pos: {
        get: function() {
            return this.createVector(this.pmouseX, this.pmouseY);
        }
    },
    mouse_prev_pos_x: {
        get: function() {
            return this.pmouseX;
        }
    },
    mouse_prev_pos_y: {
        get: function() {
            return this.pmouseY;
        }
    },
    mouse_wheel: {
        get: function() {
            return this._mouseWheel;
        }
    },
    mouse_window_pos: {
        get: function() {
            return this.createVector(this.winMouseX, this.winMouseY);
        }
    },
    mouse_window_pos_x: {
        get: function() {
            return this.winMouseX;
        }
    },
    mouse_window_pos_y: {
        get: function() {
            return this.winMouseY;
        }
    },
    mouse_prev_window_pos: {
        get: function() {
            return this.createVector(this.pwinMouseX, this.pwinMouseY);
        }
    },
    mouse_window_prev_pos_x: {
        get: function() {
            return this.pwinMouseX;
        }
    },
    mouse_window_prev_pos_y: {
        get: function() {
            return this.pwinMouseY;
        }
    },
    move_threshold: {
        get: function() {
            return this._moveThreshold;
        },
        set: function(val) {
            this.setMoveThreshold(val);
        }
    },
    moved: {
        get: function() {
            return this.createVector(this.movedX, this.movedY);
        }
    },
    moved_x: {
        get: function() {
            return this.movedX;
        }
    },
    moved_y: {
        get: function() {
            return this.movedY;
        }
    },
    pointer_lock_request: {
        get: function() {
            return document.pointerLockElement === this._curElement.elt;
        },
        set: function(val) {
            if (val) this.requestPointerLock();
            else this.exitPointerLock();
        }
    },
    shake_threshold: {
        get: function() {
            return this._shakeThreshold;
        },
        set: function(val) {
            this.setShakeThreshold(val);
        }
    }
});

},{"../utils/p5Modifiers":"kkqqW"}],"90xPG":[function(require,module,exports) {
var _p5Modifiers = require("../utils/p5Modifiers");
var _core = require("../core");
var _shapeProps = require("../properties/shape_props");
/**
 * Draw an image to the canvas.
 *
 * This element can be used with different numbers of attributes. The
 * simplest use requires only three attributes: img, x, and y—where (x, y) is
 * the position of the image. Two more attributes can optionally be added to
 * specify the width and height of the image.
 *
 * This element can also be used with eight Number attributes. To
 * differentiate between all these attributes, p5.js uses the language of
 * "destination rectangle" (which corresponds to "dx", "dy", etc.) and "source
 * image" (which corresponds to "sx", "sy", etc.) below. Specifying the
 * "source image" dimensions can be useful when you want to display a
 * subsection of the source image instead of the whole thing.
 *
 * This element can also be used to draw images without distorting the original aspect ratio,
 * by adding 9th attribute, fit, which can either be COVER or CONTAIN.
 * CONTAIN, as the name suggests, contains the whole image within the specified destination box
 * without distorting the image ratio.
 * COVER covers the entire destination box.
 *
 *
 *
 * @element image
 * @attribute  {p5.Image|p5.Element|p5.Texture} img    the image to display
 * @attribute  {p5.Image|p5.Element|p5.Texture} img
 * @attribute  {Number}   dx     the x-coordinate of the destination
 *                           rectangle in which to draw the source image
 * @attribute  {Number}   dy     the y-coordinate of the destination
 *                           rectangle in which to draw the source image
 * @attribute  {Number}   dWidth  the width of the destination rectangle
 * @attribute  {Number}   dHeight the height of the destination rectangle
 * @attribute  {Number}   sx     the x-coordinate of the subsection of the source
 * image to draw into the destination rectangle
 * @attribute  {Number}   sy     the y-coordinate of the subsection of the source
 * image to draw into the destination rectangle
 * @attribute {Number}    [sWidth] the width of the subsection of the
 *                           source image to draw into the destination
 *                           rectangle
 * @attribute {Number}    [sHeight] the height of the subsection of the
 *                            source image to draw into the destination rectangle
 * @attribute {Constant} [fit] either CONTAIN or COVER
 * @attribute {Constant} [xAlign] either LEFT, RIGHT or CENTER default is CENTER
 * @attribute {Constant} [yAlign] either TOP, BOTTOM or CENTER default is CENTER
 */ class Image extends (0, _shapeProps.addXY)((0, _shapeProps.addWidthHeight)((0, _core.RenderedElement))) {
    static overloads = [
        "img, x, y, [width], [height]",
        "img, dx, dy, dWidth, dHeight, sx, sy, [sWidth], [sHeight]", 
    ];
    /**
   * Sets the fill value for displaying images. Images can be tinted to
   * specified colors or made transparent by including an alpha value.
   *
   * To apply transparency to an image without affecting its color, use
   * white as the tint color and specify an alpha value. For instance,
   * tint(255, 128) will make an image 50% transparent (assuming the default
   * alpha range of 0-255, which can be changed with color_mode.
   *
   * The value for the gray parameter must be less than or equal to the current
   * maximum value as specified by color_mode. The default maximum value is
   * 255.
   *
   * @type {p5.Color}
   */ get tint() {
        return this.pInst.color(this.pInst._renderer._tint);
    }
    set tint(val) {
        if (val === this.pInst.NONE) this.pInst.noTint();
        else this.pInst.tint(...arguments);
    }
}
customElements.define("p-image", Image);
(0, _p5Modifiers.defineRendererGetterSetters)("imageMode");

},{"../utils/p5Modifiers":"kkqqW","../core":"cTP0J","../properties/shape_props":"4WDTj"}],"9XipF":[function(require,module,exports) {
var _p5Modifiers = require("../utils/p5Modifiers");
(0, _p5Modifiers.defineSnakeAlias)("createWriter");
(0, _p5Modifiers.defineProperties)({
    http_post: {
        set: function() {
            this.httpPost(...arguments);
        }
    },
    http_do: {
        set: function() {
            this.httpDo(...arguments);
        }
    },
    save_file: {
        set: function() {
            this.save(...arguments);
        }
    },
    save_json_file: {
        set: function() {
            this.saveJSON(...arguments);
        }
    },
    save_strings_file: {
        set: function() {
            this.saveStrings(...arguments);
        }
    },
    save_table_file: {
        set: function() {
            this.saveTable(...arguments);
        }
    }
});

},{"../utils/p5Modifiers":"kkqqW"}],"lm7DH":[function(require,module,exports) {
var _core = require("../core");
var _shapeProps = require("../properties/shape_props");
var _colorProps = require("../properties/color_props");
var _3DProps = require("../properties/3d_props");
var _2DShapeElements = require("./2d_shape_elements");
var _shapeMethods = require("../methods/shape_methods");
var _transformProps = require("../properties/transform_props");
var _transformMethods = require("../methods/transform_methods");
class WebGLGeometry extends (0, _colorProps.addFillStroke)((0, _transformProps.add3DTransformProps)((0, _transformMethods.add3DTransformMethods)((0, _3DProps.add3DProps)((0, _core.RenderedElement))))) {
}
class Normal extends (0, _shapeProps.addXYZ)((0, _core.RenderedElement)) {
    static overloads = [
        "vector",
        "x, y, z"
    ];
}
customElements.define("p-normal", Normal);
class Plane extends (0, _shapeProps.addWidthHeight)(WebGLGeometry) {
    static overloads = "[width], [height], [detail_x], [detail_y]";
}
customElements.define("p-plane", Plane);
class Box extends (0, _shapeProps.addWidthHeight)(WebGLGeometry) {
    static overloads = [
        "[width], [height], [depth], [detail_x], [detail_y]"
    ];
}
customElements.define("p-box", Box);
class Sphere extends WebGLGeometry {
    static overloads = [
        "[radius], [detail_x], [detail_y]"
    ];
}
customElements.define("p-sphere", Sphere);
class Cylinder extends WebGLGeometry {
    static overloads = [
        "[radius], [height], [detail_x], [detail_y], [bottomCap], [topCap]", 
    ];
}
customElements.define("p-cylinder", Cylinder);
class Cone extends WebGLGeometry {
    static overloads = [
        "[radius], [height], [detail_x], [detail_y], [cap]"
    ];
}
customElements.define("p-cone", Cone);
class Ellipsoid extends WebGLGeometry {
    static overloads = [
        "[radius_x], [radius_y], [radius_z], [detail_x], [detail_y]", 
    ];
}
customElements.define("p-ellipsoid", Ellipsoid);
class Torus extends WebGLGeometry {
    static overloads = [
        "[radius], [tubeRadius], [detailX], [detailY]"
    ];
}
customElements.define("p-torus", Torus);
//  TODO - test when preload implemented
class LoadModel extends (0, _core.RenderedElement) {
    static overloads = [
        "path, normalize, [successCallback], [failureCallback], [fileType]",
        "path, [successCallback], [failureCallback], [fileType]", 
    ];
}
customElements.define("p-load-model", LoadModel);
class Model extends WebGLGeometry {
    static overloads = [
        "model"
    ];
}
customElements.define("p-model", Model);
const remove3DFromRenderFunctionName = (baseClass)=>class extends baseClass {
        constructor(){
            super();
            this.renderFunctionName = this.renderFunctionName.slice(0, -2);
        }
    };
const addDetail = (baseClass)=>class extends baseClass {
        #detail = 25;
        /**
     * specifies the number of vertices that makes up the perimeter of the shape.
     * Default value is 25. Won't draw a stroke for a detail of more than 50.
     * @type {Integer}
     */ get detail() {
            return this.#detail;
        }
        set detail(val) {
            this.#detail = val;
        }
    };
const addDetailXY = (baseClass)=>class extends baseClass {
        #detail_x = 2;
        #detail_y = 2;
        /**
     * number of segments in the x-direction
     * @type {Integer}
     */ get detail_x() {
            return this.#detail_x;
        }
        set detail_x(val) {
            this.#detail_x = val;
        }
        /**
     * number of segments in the y-direction
     * @type {Integer}
     */ get detail_y() {
            return this.#detail_y;
        }
        set detail_y(val) {
            this.#detail_y = val;
        }
    };
/**
 * Draws an arc onto a ```<canvas-3d>```.
 * The origin may be changed with the ellipse_mode property.
 *
 * The arc is always drawn clockwise from wherever start falls to wherever
 * stop falls on the ellipse. Adding or subtracting TWO_PI to either angle
 * does not change where they fall. If both start and stop fall at the same
 * place, a full ellipse will be drawn. Be aware that the y-axis increases in
 * the downward direction, therefore angles are measured clockwise from the
 * positive x-direction ("3 o'clock").
 * @element arc-3d
 */ class Arc3D extends remove3DFromRenderFunctionName((0, _shapeProps.addXY)((0, _2DShapeElements.addArcProps)(addDetail((0, _3DProps.add3DProps)((0, _core.RenderedElement)))))) {
    static overloads = [
        "x, y, width, height, start_angle, stop_angle, [mode], [detail]", 
    ];
}
customElements.define("p-arc-3d", Arc3D);
class Base2DTo3D extends (0, _transformProps.add3DTransformProps)((0, _3DProps.add3DProps)((0, _core.RenderedElement))) {
}
/**
 * Draws an ellipse (oval) onto a ```<canvas-3d>```. If no height is specified, the
 * value of width is used for both the width and height. If a
 * negative height or width is specified, the absolute value is taken.
 *
 * An ellipse with equal width and height is a circle. The origin may be
 * changed with the ellipseMode() function.
 * @element ellipse-3d
 */ class Ellipse3D extends remove3DFromRenderFunctionName((0, _shapeProps.addXY)((0, _shapeProps.addWidthHeight)((0, _colorProps.addFillStroke)(Base2DTo3D)))) {
    static overloads = [
        "x, y, width, [height], [detail]"
    ];
}
customElements.define("p-ellipse-3d", Ellipse3D);
/**
 * Draws a circle onto a ```<canvas-3d>```. A circle is a simple closed shape. It is the
 * set of all points in a plane that are at a given distance from a given
 * point, the center.
 * @element circle
 */ class Circle3D extends remove3DFromRenderFunctionName((0, _shapeProps.addXY)((0, _2DShapeElements.addDiameter)((0, _colorProps.addFillStroke)(Base2DTo3D)))) {
    static overloads = [
        "x, y, diameter"
    ];
}
customElements.define("p-circle-3d", Circle3D);
/**
 * Draws a line (a direct path between two points) onto a ```<canvas-3d>```. Its width
 * can be modified by using the stroke_weight property. A line cannot be
 * filled, therefore the fill_color property will not affect the color of a
 * line. So to color a line, use the stroke property.
 * @element line-3d
 */ class Line3D extends remove3DFromRenderFunctionName((0, _shapeProps.addXYZ1)((0, _shapeProps.addXYZ2)((0, _colorProps.addStroke)(Base2DTo3D)))) {
    static overloads = [
        "x1, y1, z1, x2, y2, z2"
    ];
}
customElements.define("p-line-3d", Line3D);
/**
 * Draws a point, a coordinate in space at the dimension of one pixel onto a ```<canvas-3d>```.
 * The color of the point is changed with the stroke property. The size of
 * the point can be changed with the stroke_weight property.
 * @element point
 */ class Point3D extends remove3DFromRenderFunctionName((0, _shapeProps.addXYZ)((0, _colorProps.addStroke)(Base2DTo3D))) {
    static overloads = [
        "x, y, z"
    ];
}
customElements.define("p-point-3d", Point3D);
/**
 * Draws a quad onto a ```<canvas-3d>```. A quad is a quadrilateral, a four-sided
 * polygon. It is similar to a rectangle, but the angles between its edges
 * are not constrained to ninety degrees. The x1 and y1 properties set the
 * first vertex and the subsequent pairs should proceed clockwise or
 * counter-clockwise around the defined shape.
 * @element quad
 */ class Quad3D extends remove3DFromRenderFunctionName((0, _shapeProps.addXYZ1)((0, _shapeProps.addXYZ2)((0, _shapeProps.addXYZ3)((0, _shapeProps.addXYZ4)(addDetailXY((0, _colorProps.addFillStroke)(Base2DTo3D))))))) {
    static overloads = [
        "x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, [detail_x], [detail_y]", 
    ];
}
customElements.define("p-quad-3d", Quad3D);
/**
 * Draws a rectangle onto a ```<canvas-3d>```. A rectangle is a four-sided closed shape
 * with every angle at ninety degrees. By default, the x and y properties
 * set the location of the upper-left corner, w sets the width, and h sets
 * the height. The way these properties are interpreted may be changed with
 * the rect_mode property.
 * @element rect
 */ class Rect3D extends remove3DFromRenderFunctionName((0, _shapeProps.addXY)((0, _shapeProps.addWidthHeight)((0, _colorProps.addFillStroke)(Base2DTo3D)))) {
    static overloads = [
        "x, y, width, [height], [top_left_radius], [top_right_radius], [bottom_right_radius], [bottom_left_radius]", 
    ];
}
customElements.define("p-rect-3d", Rect3D);
/**
 * Draws a triangle onto a ```<canvas-3d>```. A triangle is a plane created by connecting
 * three points. x1 and y1 specify the first point, x2 and y2 specify the
 * second point, and x3 and y3 specify the
 * third point.
 * @element triangle
 */ class Triangle3D extends remove3DFromRenderFunctionName((0, _shapeProps.addXYZ1)((0, _shapeProps.addXYZ2)((0, _shapeProps.addXYZ3)((0, _colorProps.addFillStroke)(Base2DTo3D))))) {
    static overloads = [
        "x1, y1, z1, x2, y2, z2, x3, y3, z3"
    ];
}
customElements.define("p-triangle-3d", Triangle3D);
/**
 * Draws a cubic Bezier curve onto a ```<canvas-3d>```. These curves are defined by a
 * series of anchor and control points. x1 and y1 specify
 * the first anchor point and x4 and y4 specify the other
 * anchor point, which become the first and last points on the curve. (x2, y2)
 * and (x3, y3) specify the two control points which define the shape
 * of the curve. Approximately speaking, control points "pull" the curve
 * towards them.
 *
 * Bezier curves were developed by French automotive engineer Pierre Bezier,
 * and are commonly used in computer graphics to define gently sloping curves.
 * @element bezier-3d
 */ class Bezier3D extends remove3DFromRenderFunctionName((0, _shapeProps.addXYZ1)((0, _shapeProps.addXYZ2)((0, _shapeProps.addXYZ3)((0, _shapeProps.addXYZ4)((0, _colorProps.addFillStroke)((0, _3DProps.add3DProps)((0, _shapeMethods.addBezierMethods)((0, _core.RenderedElement))))))))) {
    static overloads = [
        "x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4"
    ];
}
customElements.define("p-bezier-3d", Bezier3D);
/**
 * Draws a curved line onto a ```<canvas-3d>``` between two points,
 * given as (x2, y2) and (x3, y3).
 * (x1, y1) is a control point, as
 * if the curve came from this point even though it's not drawn. (x4, y4) similarly describes
 * the other control point.
 *
 * Longer curves can be created by putting a series of ```<curve-3d>``` elements
 * together or using ```<curve-vertex>```. The curve_tightness property provides control
 * for the visual quality of the curve.
 * The ```<curve>``` element is an implementation of Catmull-Rom splines.
 * @element curve
 */ class Curve3D extends remove3DFromRenderFunctionName((0, _shapeProps.addXYZ1)((0, _shapeProps.addXYZ2)((0, _shapeProps.addXYZ3)((0, _shapeProps.addXYZ4)((0, _shapeProps.addCurveTightness)((0, _colorProps.addFillStroke)((0, _3DProps.add3DProps)((0, _shapeMethods.addCurveMethods)((0, _core.RenderedElement)))))))))) {
    static overloads = [
        "x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4"
    ];
}
customElements.define("p-curve-3d", Curve3D);
/**
 * Use the ```<contour-3d>``` element to create negative shapes
 * within a ```<shape-3d>``` element such as the center of the letter 'O'.
 * The vertices of the ```<contour-3d>``` are defined by its
 * ```<vertex-3d>``` and ```<curve-vertex-3d>``` children.
 * The vertices that define a negative shape must "wind" in the opposite direction
 * from the exterior shape. First draw vertices for the exterior clockwise order, then for internal shapes, draw vertices
 * shape in counter-clockwise.
 *
 * This element must be a child of a ```<shape-3d>```.
 * @element contour
 */ class Contour3D extends remove3DFromRenderFunctionName((0, _colorProps.addFillStroke)((0, _3DProps.add3DProps)((0, _core.RenderedElement)))) {
    renderFunctionName = "beginContour";
    endRender() {
        this.pInst.endContour();
    }
}
customElements.define("p-contour-3d", Contour3D);
/**
 * Using the ```<shape-3d>``` element allow creating more
 * complex forms on a ```<canvas-3d>```.
 * The vertices of the shape are defined by its ```<vertex-3d>```,
 * ```<curve-vertex-3d>```, and/or ```<quadratic-vertex-3d>``` children.
 * The value of the kind property tells it which
 * types of shapes to create from the provided vertices. With no mode
 * specified, the shape can be any irregular polygon.
 *
 *
 * Transformations such as translate, angle, and scale do not work on children on ```<shape-3d>```.
 * It is also not possible to use other shapes, such as
 * ```<ellipse-3d>``` or ```<rect-3d>``` as children of ```<shape-3d>```.
 * @element shape-3d
 */ class Shape3D extends (0, _2DShapeElements.addShapeElementProps)((0, _colorProps.addFillStroke)(Base2DTo3D)) {
}
customElements.define("p-shape-3d", Shape3D);
const addUV = (baseClass)=>class extends baseClass {
        #u;
        #v;
        /**
     * the vertex's texture u-coordinate
     * @type {number}
     */ get u() {
            return this.#u;
        }
        set u(val) {
            this.#u = val;
        }
        /**
     * the vertex's texture v-coordinate
     * @type {number}
     */ get v() {
            return this.#v;
        }
        set v(val) {
            this.#v = val;
        }
    };
/**
 * All shapes are constructed by connecting a series of vertices. ```<vertex-3d>```
 * is used to specify the vertex coordinates for shapes on a ```<canvas-3d>```.
 * It is used exclusively as a child of the ```<shape-3d>``` element.
 * @element vertex
 */ class Vertex3D extends (0, _shapeProps.addXYZ)(addUV((0, _core.RenderedElement))) {
    static overloads = [
        "x, y, z, [u], [v]"
    ];
}
customElements.define("p-vertex-3d", Vertex3D);
/**
 * Specifies vertex coordinates for quadratic Bezier curves on a ```<canvas-3d>```.
 * Each ```<quadratic-vertex-3d>```
 * defines the position of one control points and one
 * anchor point of a Bezier curve, adding a new segment to a line or shape.
 * The first ```<quadratic-vertex-3d>``` child of a ```<shape>``` element
 * must have a ```<vertex-3d>``` sibling above it to set the first anchor point.
 *
 * This element must be a child of a ```<shape-3d>``` element
 * and only when there is no MODE or POINTS property specified on the
 *  ```<shape-3d>```.
 */ class QuadraticVertex3D extends (0, _shapeProps.addXYZ3)((0, _core.RenderedElement)) {
    static overloads = [
        "cx, cy, cz, x3, y3, z3"
    ];
}
customElements.define("p-quadratic-vertex-3d", QuadraticVertex3D);
/**
 * Specifies vertex coordinates for curves. This function may only
 * be used as a child of the ```<shape-3d>``` element and only when there
 * is no MODE property specified on the ```<shape-3d>``.
 *
 * The first and last points in a series of ```<curve-vertex-3d>``` lines
 * will be used to
 * guide the beginning and end of the curve. A minimum of four
 * points is required to draw a tiny curve between the second and
 * third points. Adding a fifth point with ```<curve-vertex>``` will draw
 * the curve between the second, third, and fourth points. The
 * ```<curve-vertex>``` element is an implementation of Catmull-Rom
 * splines.
 */ class CurveVertex3D extends remove3DFromRenderFunctionName((0, _shapeProps.addXYZ)((0, _shapeProps.addCurveTightness)((0, _colorProps.addFillStroke)((0, _3DProps.add3DProps)((0, _core.RenderedElement)))))) {
    static overloads = [
        "x, y, z"
    ];
}
customElements.define("p-curve-vertex-3d", CurveVertex3D);

},{"../core":"cTP0J","../properties/shape_props":"4WDTj","../properties/3d_props":"6u7a3","../properties/color_props":"8V5jU","./2d_shape_elements":"5HFQ1","../methods/shape_methods":"gkECc","../properties/transform_props":"iZSkq","../methods/transform_methods":"8Bjut"}],"6u7a3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "add3DProps", ()=>add3DProps);
parcelHelpers.export(exports, "WebGLLight", ()=>WebGLLight);
parcelHelpers.export(exports, "addSpecularColor", ()=>addSpecularColor);
parcelHelpers.export(exports, "addLightFalloff", ()=>addLightFalloff);
parcelHelpers.export(exports, "addRectMode", ()=>addRectMode);
parcelHelpers.export(exports, "add3DShapeStyling", ()=>add3DShapeStyling);
var _core = require("../core");
var _colorProps = require("../properties/color_props");
p5.prototype.DEFAULT = "default";
p5.prototype.AMBIENT = "ambient";
p5.prototype.SPECULAR = "specular";
p5.prototype.EMISSIVE = "emissive";
const add3DProps = (baseClass)=>class extends baseClass {
        #ambient_material;
        #emissive_material;
        #shininess;
        #specular_material;
        #no_lights;
        /**
     * Sets the ambient color of the material.
     *
     * The ambient_material color is the color the object will reflect
     * under **any** lighting.
     *
     * Consider an ambient_material with the color yellow (255, 255, 0).
     * If the light emits the color white (255, 255, 255), then the object
     * will appear yellow as it will reflect the red and green components
     * of the light. If the light emits the color red (255, 0, 0), then
     * the object will appear red as it will reflect the red component
     * of the light. If the light emits the color blue (0, 0, 255),
     * then the object will appear black, as there is no component of
     * the light that it can reflect.
     * @type {p5.Color}
     */ get ambient_material() {
            return this.#ambient_material;
        }
        set ambient_material(val) {
            if (Array.isArray(val)) this.pInst.ambientMaterial(...val);
            else this.pInst.ambientMaterial(val);
            this.#ambient_material = this.pInst.color(val);
        }
        /**
     * Sets the emissive color of the material.
     *
     * An emissive material will display the emissive color at
     * full strength regardless of lighting. This can give the
     * appearance that the object is glowing.
     *
     * Note, "emissive" is a misnomer in the sense that the material
     * does not actually emit light that will affect surrounding objects.
     *
     * @type {p5.Color}
     */ get emissive_material() {
            return this.#emissive_material;
        }
        set emissive_material(val) {
            if (Array.isArray(val)) this.pInst.emissiveMaterial(...val);
            else this.pInst.emissiveMaterial(val);
            this.#ambient_material = this.pInst.color(val);
        }
        /**
     * Sets the current material as a normal material.
     *
     * A normal material is not affected by light. It is often used as
     * a placeholder material when debugging.
     *
     * Surfaces facing the X-axis become red, those facing the Y-axis
     * become green, and those facing the Z-axis become blue.
     *
     * @type {boolean}
     */ get normal_material() {
            return this.pInst._renderer.useNormalMaterial;
        }
        set normal_material(val) {
            if (val) this.pInst.normalMaterial();
        }
        /**
     * Sets the <a href="#/p5.Shader">p5.Shader</a> object to
     * be used to render subsequent shapes.
     *
     * Custom shaders can be created using the
     * create_shader() method and
     * ```<shader>``` element.
     *
     * Set shader="DEFAULT" to restore the default shaders.
     *
     * Note, shaders can only be used in WEBGL mode.
     * @type {p5.Shader}
     */ get shader() {
            return [
                this.pInst._renderer.userStrokeShader,
                this.pInst._renderer.userFillShader, 
            ];
        }
        set shader(val) {
            const { pInst  } = this;
            if (val === pInst.DEFAULT) pInst.resetShader();
            else pInst.shader(val);
        }
        /**
     * Sets the amount of gloss ("shininess") of a
     * specular_material.
     *
     * The default and minimum value is 1.
     * @type {number}
     * */ get shininess() {
            return this.#shininess;
        }
        set shininess(val) {
            this.pInst.shininess(val);
            this.#shininess = val;
        }
        /**
     * Sets the specular color of the material.
     *
     * A specular material is reflective (shiny). The shininess can be
     * controlled by the shininess property.
     *
     * Like ambient_material,
     * the specular_material color is the color the object will reflect
     * under ```<ambient-light>```.
     * However unlike ambient_material, for all other types of lights
     * ```<directional-light>```,
     * ```<point-light>```,
     * ```spot-light>```,
     * a specular material will reflect the **color of the light source**.
     * This is what gives it its "shiny" appearance.
     *
     * @type {p5.Color}
     */ get specular_material() {
            return this.#specular_material;
        }
        set specular_material(val) {
            if (Array.isArray(val)) this.pInst.specularMaterial(...val);
            else this.pInst.specularMaterial(val);
            this.#specular_material = this.pInst.color(val);
        }
        /**
     * Sets the texture that will be used to render subsequent shapes.
     *
     * A texture is like a "skin" that wraps around a 3D geometry. Currently
     * supported textures are images, video, and offscreen renders.
     *
     * To texture a geometry created by a ```<shape>``` element,
     * you will need to specify uv coordinates in ```<vertex>``` element.
     *
     * Note, texture can only be used in WEBGL mode.
     *
     * @type {p5.Image|p5.MediaElement|p5.Graphics|p5.Texture}
     */ get texture() {
            return this.pInst._renderer._tex;
        }
        set texture(val) {
            this.pInst.texture(val);
        }
        /**
     * Sets the coordinate space for texture mapping. The default mode is IMAGE
     * which refers to the actual coordinates of the image.
     * NORMAL refers to a normalized space of values ranging from 0 to 1.
     *
     * With IMAGE, if an image is 100×200 pixels, mapping the image onto the
     * entire
     * size of a quad would require the points (0,0) (100, 0) (100,200) (0,200).
     * The same mapping in NORMAL is (0,0) (1,0) (1,1) (0,1).
     *
     * @type {IMAGE|NORMAL}
     */ get texture_mode() {
            return this.pInst._renderer.textureMode;
        }
        set texture_mode(val) {
            this.pInst.textureMode(val);
        }
        /**
     * Sets the global texture wrapping mode. This controls how textures behave
     * when their uv's go outside of the 0 to 1 range. There are three options:
     * CLAMP, REPEAT, and MIRROR.
     *
     * CLAMP causes the pixels at the edge of the texture to extend to the bounds.
     * REPEAT causes the texture to tile repeatedly until reaching the bounds.
     * MIRROR works similarly to REPEAT but it flips the texture with every new tile.
     *
     * REPEAT & MIRROR are only available if the texture
     * is a power of two size (128, 256, 512, 1024, etc.).
     *
     * This method will affect all textures in your sketch until another element
     * sets texture_mode.
     *
     * If only one value is provided, it will be applied to both the
     * horizontal and vertical axes.
     * @type {[CLAMP|REPEAT|MIRROR, CLAMP|REPEAT|MIRROR]}
     */ get texture_wrap() {
            return [
                this.pInst._renderer.textureWrapX,
                this.pInst._renderer.textureWrapY, 
            ];
        }
        set texture_wrap(val) {
            if (Array.isArray(val)) this.pInst.textureWrap(...val);
            else this.pInst.textureWrap(val);
        }
        /**
     * Removes all lights present in a sketch.
     *
     * All subsequent geometry is rendered without lighting (until a new
     * light is created with a lighting element (
     * ```<lights>```,
     * ```<ambient-light>```,
     * ```<directional-light>```,
     * ```<point-light>```,
     * ```<spot-light>```).
     * @type {boolean}
     */ get no_lights() {
            return this.#no_lights;
        }
        set no_lights(val) {
            this.#no_lights = val;
            if (val == true) this.pInst.noLights();
        }
    };
class WebGLLight extends (0, _core.RenderedElement) {
    draw(inherited) {
        //  Set no_lights to false so that children won't delete this light
        super.draw({
            ...inherited,
            no_lights: false
        });
    }
}
const addSpecularColor = (baseClass)=>class extends baseClass {
        #specular_color;
        /**
     * Sets the color of the specular highlight of a non-ambient light
     * (i.e. all lights except ```<ambient-light>```).
     *
     * specular_color affects only the lights which are created by
     * this element or its children
     *
     * This property is used in combination with
     * <a href="#/p5/specularMaterial">specularMaterial()</a>.
     * If a geometry does not use specular_material, this property
     * will have no effect.
     *
     * The default color is white (255, 255, 255), which is used if
     * specular_color is not explicitly set.
     *
     * Note: specular_color is equivalent to the Processing function
     * <a href="https://processing.org/reference/lightSpecular_.
     * html">lightSpecular</a>.
     *
     * @type {p5.Color}
     */ get specular_color() {
            return this.#specular_color;
        }
        set specular_color(val) {
            const { pInst  } = this;
            const c = Array.isArray(val) ? pInst.color(...val) : pInst.color(val);
            pInst.specularColor(c);
            this.#specular_color = c;
        }
    };
const addLightFalloff = (baseClass)=>class extends baseClass {
        #light_falloff;
        /**
     * Sets the falloff rate for ```<point-light>```
     * and ```<spot-light>```.
     *
     * light_falloff affects only this element and its children.
     *
     * The values are `constant`, `linear`, an `quadratic` and are used to calculate falloff as follows:
     *
     * d = distance from light position to vertex position
     *
     * falloff = 1 / (CONSTANT + d \* LINEAR + (d \* d) \* QUADRATIC)
     * @type {[number, number, number]}
     */ get light_falloff() {
            return this.#light_falloff;
        }
        set light_falloff([constant, linear, quadratic]) {
            const { pInst  } = this;
            pInst.lightFalloff(constant, linear, quadratic);
            this.#light_falloff = [
                pInst._renderer.constantAttenuation,
                pInst._renderer.linearAttenuation,
                pInst._renderer.quadraticAttenuation, 
            ];
        }
    };
const addRectMode = (baseClass)=>class extends baseClass {
        #rect_mode;
        /**
     * Modifies the location from which rectangles are drawn by changing the way
     * in which x and y coordinates are interpreted.
     *
     * The default mode is CORNER, which interprets the x and y as the
     * upper-left corner of the shape.
     *
     * rect_mode="CORNERS" interprets x and y as the location of
     * one of the corners, and width and height as the location of
     * the diagonally opposite corner. Note, the rectangle is drawn between the
     * coordinates, so it is not necessary that the first corner be the upper left
     * corner.
     *
     * rect_mode="CENTER" interprets x and y as the shape's center
     * point.
     *
     * rect_mode="RADIUS" also uses x and y as the shape's
     * center
     * point, but uses width and height to specify half of the shape's
     * width and height respectively.
     *
     * The value to this property must be written in ALL CAPS because they are
     * predefined as constants in ALL CAPS.
     *
     * @type {CORNER|CORNERS|CENTER|RADIUS}
     */ get rect_mode() {
            return this.#rect_mode;
        }
        set rect_mode(mode) {
            this.pInst.rectMode(mode);
            this.#rect_mode = this.pInst._renderer._rectMode;
        }
    };
const add3DShapeStyling = (baseClass)=>class extends baseClass {
        #smooth = false;
        /**
     * smooth="true" draws all geometry with smooth (anti-aliased) edges. smooth="true" will also
     * improve image quality of resized images. On a 3D canvas, smooth is false
     * by default, so it is necessary to set smooth="true" if you would like
     * smooth (antialiased) edges on your geometry.
     * @type {boolean}
     */ get smooth() {
            return this.#smooth;
        }
        set smooth(val) {
            if (typeof val !== "boolean") return console.error(`${this.tagName}'s smooth property is being set to ${val}, but it may only be set to true or false.`);
            if (val) this.pInst.smooth();
            else this.pInst.noSmooth();
            this.#smooth = val;
        }
    };

},{"../core":"cTP0J","../properties/color_props":"8V5jU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"huIwd":[function(require,module,exports) {
var _3DProps = require("../properties/3d_props");
/**
 * Creates an ambient light with the given color.
 *
 * Ambient light does not come from a specific direction.
 * Objects are evenly lit from all sides. Ambient lights are
 * almost always used in combination with other types of lights.
 * @element ambient-light
 * @attribute {Number}   v1     red or hue value relative to the current color
 *                                range
 * @attribute {Number}   v2     green or saturation value relative to the
 *                                current color range
 * @attribute {Number}   v3     blue or brightness value relative to the current
 *                                color range
 * @attribute {Number}   alpha  alpha value relative to current color range
 *                                (default is 0-255)
 * @attribute {Number}   gray   number specifying value between
 *                                white and black
 * @attribute {String}   value  a color string
 * @attribute {Number[]} values an array containing the red,green,blue &
 *                                 and alpha components of the color
 * @attribute {p5.Color} color  color as a <a
 *                                 href="https://p5js.org/reference/#/p5.Color"
 *                                 target="_blank">p5.Color</a>
 */ class AmbientLight extends (0, _3DProps.WebGLLight) {
    static overloads = [
        "v1, v2, v3, [alpha]",
        "gray, [alpha]",
        "value",
        "values",
        "color", 
    ];
}
customElements.define("p-ambient-light", AmbientLight);
/**
 * Creates a directional light with the given color and direction.
 *
 * Directional light comes from one direction.
 * The direction is specified as numbers inclusively between -1 and 1.
 * For example, setting the direction as (0, -1, 0) will cause the
 * geometry to be lit from below (since the light will be facing
 * directly upwards). Similarly, setting the direction as (1, 0, 0)
 * will cause the geometry to be lit from the left (since the light
 * will be facing directly rightwards).
 *
 * Directional lights do not have a specific point of origin, and
 * therefore cannot be positioned closer or farther away from a geometry.
 *
 * A maximum of **5** directional lights can be active at once.
 * @element    directional-light
 * @attribute  {Number}   v1     red or hue value relative to the current color
 *                                range
 * @attribute  {Number}   v2     green or saturation value relative to the
 *                                current color range
 * @attribute  {Number}   v3     blue or brightness value relative to the
 *                                current color range
 * @attribute  {Number}   x      x component of direction (inclusive range of
 *                                -1 to 1)
 * @attribute  {Number}   y      y component of direction (inclusive range of
 *                                -1 to 1)
 * @attribute  {Number}   z      z component of direction (inclusive range of
 *                                -1 to 1)
 * @attribute  {p5.Vector} direction  direction of light as a <a
 *                             href="https://p5js.org/reference/#/p5.Vector"
 *                             >p5.Vector</a>
 * @attribute {p5.Color} color  color as a <a
 *                                 href="https://p5js.org/reference/#/p5.Color"
 *                                 target="_blank">p5.Color</a>
 */ class DirectionalLight extends (0, _3DProps.addSpecularColor)((0, _3DProps.WebGLLight)) {
    static overloads = [
        "v1, v2, v3, x, y, z",
        "v1, v2, v3, direction",
        "color, x, y, z",
        "color, direction", 
    ];
}
customElements.define("p-directional-light", DirectionalLight);
/**
 * Creates a point light with the given color and position.
 *
 * A point light emits light from a single point in all directions.
 * Because the light is emitted from a specific point (position),
 * it has a different effect when it is positioned farther vs. nearer
 * an object.
 *
 * A maximum of **5** point lights can be active at once.
 *
 * @attribute  {Number}   v1   red or hue value relative to the current color
 *                                range
 * @attribute  {Number}   v2   green or saturation value relative to the
 *                                current color range
 * @attribute  {Number}   v3   blue or brightness value relative to the
 *                                current color range
 * @attribute  {Number}    x   x component of position
 * @attribute  {Number}    y   y component of position
 * @attribute  {Number}    z   z component of position
 * @attribute  {p5.Vector}  position position of light as a <a
 *                            href="https://p5js.org/reference/#/p5.Vector"
 *                            >p5.Vector</a>
 * @attribute  {p5.Color|Number[]|String} color  color as a <a
 *                href="https://p5js.org/reference/#/p5.Color">p5.Color</a>,
 *                as an array, or as a CSS string
 */ class PointLight extends (0, _3DProps.addLightFalloff)((0, _3DProps.addSpecularColor)((0, _3DProps.WebGLLight))) {
    static overloads = [
        "v1, v2, v3, x, y, z",
        "v1, v2, v3, position",
        "color, x, y, z",
        "color, position", 
    ];
}
customElements.define("p-point-light", PointLight);
/**
 * Places an ambient and directional light in the scene.
 * The lights are set to <ambient-light v1="128" v2="128" v3="128"> and
 * <directional-light v1="128" v2="128" v3'="128" x="0" y="0" z="-1">.
 * @element lights
 */ class Lights extends (0, _3DProps.addSpecularColor)((0, _3DProps.WebGLLight)) {
    static overloads = [
        ""
    ];
}
customElements.define("p-lights", Lights);
/**
 * Creates a spot light with the given color, position,
 * light direction, angle, and concentration.
 *
 * Like a ```<point-light>```, a ```<spot-light>```
 * emits light from a specific point (position). It has a different effect
 * when it is positioned farther vs. nearer an object.
 *
 * However, unlike a ```<point-light>```, the light is emitted in **one
 * direction**
 * along a conical shape. The shape of the cone can be controlled using
 * the `angle` and `concentration` parameters.
 *
 * The `angle` parameter is used to
 * determine the radius of the cone. And the `concentration`
 * parameter is used to focus the light towards the center of
 * the cone. Both parameters are optional, however if you want
 * to specify `concentration`, you must also specify `angle`.
 * The minimum concentration value is 1.
 *
 * A maximum of **5** spot lights can be active at once.
 *
 * @element spot-light
 * @attribute  {Number}    v1             red or hue value relative to the
 *                                            current color range
 * @attribute  {Number}    v2             green or saturation value relative
 *                                            to the current color range
 * @attribute  {Number}    v3             blue or brightness value relative
 *                                            to the current color range
 * @attribute  {Number}    x              x component of position
 * @attribute  {Number}    y              y component of position
 * @attribute  {Number}    z              z component of position
 * @attribute  {Number}    rx             x component of light direction
 *                                            (inclusive range of -1 to 1)
 * @attribute  {Number}    ry             y component of light direction
 *                                            (inclusive range of -1 to 1)
 * @attribute  {Number}    rz             z component of light direction
 *                                            (inclusive range of -1 to 1)
 * @attribute  {Number}    angle          angle of cone. Defaults to PI/3
 * @attribute  {Number}    concentration  concentration of cone. Defaults to
 *                                            100
 */ class SpotLight extends (0, _3DProps.addLightFalloff)((0, _3DProps.addSpecularColor)((0, _3DProps.WebGLLight))) {
    static overloads = [
        "v1, v2, v3, x, y, z, rx, ry, rz, [angle], [concentration]",
        "color, position, direction, [angle], [concentration]",
        "v1, v2, v3, position, direction, [angle], [concentration]",
        "color, x, y, z, direction, [angle], [concentration]",
        "color, position, rx, ry, rz, [angle], [concentration]",
        "v1, v2, v3, x, y, z, direction, [angle], [concentration]",
        "v1, v2, v3, position, rx, ry, rz, [angle], [concentration]",
        "color, x, y, z, rx, ry, rz, [angle], [concentration]", 
    ];
}
customElements.define("p-spot-light", SpotLight);

},{"../properties/3d_props":"6u7a3"}],"3u4kq":[function(require,module,exports) {
var _core = require("../core");
var _3DMethods = require("../methods/3d_methods");
var _3DProps = require("../properties/3d_props");
var _colorProps = require("../properties/color_props");
var _shapeProps = require("../properties/shape_props");
var _transformProps = require("../properties/transform_props");
var _typographyProps = require("../properties/typography_props");
/**
 * Draws text on the ```<canvas>```. The content of the text may be specified
 * by setting the content property
 * ```xml
 * <text content="'Hello world'"></text>
 * ```
 * or by adding the content between the
 * element's start and end tags.
 * ```xml
 * <text>Hello world</text>
 * ```
 *
 * Change the color of the text with the fill property. Change
 * the outline of the text with the stroke and
 * stroke_weight properties.
 *
 * The text displays in relation to the <a href="#/p5/textAlign">textAlign()</a>
 * function, which gives the option to draw to the left, right, and center of the
 * coordinates.
 *
 * The width and height properties, if specified, define a rectangular area to display within and
 * may only be used with string data. When these properties are specified,
 * they are interpreted based on the current rect_mode
 * setting. Text that does not fit completely within the rectangle specified will
 * not be drawn to the screen. If width and height are not specified, the baseline
 * alignment is the default, which means that the text will be drawn upwards
 * from x and y.
 * @element text
 */ class Text extends (0, _shapeProps.addXY)((0, _shapeProps.addWidthHeight)((0, _colorProps.addFillStroke)((0, _typographyProps.addTypographyProps)((0, _shapeProps.add2DStrokeStyling)((0, _transformProps.add2DTransformProps)((0, _core.RenderedElement))))))) {
    static overloads = [
        "content, x, y, [width], [height]"
    ];
}
customElements.define("p-text", Text);
const addFont3D = (baseClass)=>class extends baseClass {
        /**
     * The current font used by this element. This must be loaded
     * with load_font().
     * @type {p5.Font}
     */ get font() {
            return super.font;
        }
    };
/**
 * Draws text on the ```<canvas-3d>```. The content of the text may be specified
 * by setting the content property
 * ```xml
 * <text content="'Hello world'"></text>
 * ```
 * or by adding the content between the
 * element's start and end tags.
 * ```xml
 * <text>Hello world</text>
 * ```
 *
 * Change the color of the text with the fill property. Text on a 3D canvas does not
 * have a stroke property.
 *
 * The text displays in relation to the <a href="#/p5/textAlign">textAlign()</a>
 * function, which gives the option to draw to the left, right, and center of the
 * coordinates.
 *
 * The width and height properties, if specified, define a rectangular area to display within and
 * may only be used with string data. When these properties are specified,
 * they are interpreted based on the current rect_mode
 * setting. Text that does not fit completely within the rectangle specified will
 * not be drawn to the screen. If width and height are not specified, the baseline
 * alignment is the default, which means that the text will be drawn upwards
 * from x and y.
 * @element text
 */ class Text3D extends (0, _shapeProps.addXY)((0, _shapeProps.addWidthHeight)((0, _colorProps.addFill)(addFont3D((0, _typographyProps.addTypographyProps)((0, _transformProps.add3DTransformProps)((0, _3DProps.add3DProps)((0, _3DMethods.addWebGLMethods)((0, _core.RenderedElement))))))))) {
    static overloads = [
        "content, x, y, [width], [height]"
    ];
}
customElements.define("p-text-3d", Text3D);

},{"../core":"cTP0J","../methods/3d_methods":"8AVIn","../properties/3d_props":"6u7a3","../properties/color_props":"8V5jU","../properties/shape_props":"4WDTj","../properties/transform_props":"iZSkq","../properties/typography_props":"2ZhVc"}],"2ZhVc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addTypographyProps", ()=>addTypographyProps);
const addTypographyProps = (baseClass)=>class extends baseClass {
        #align = [
            p5.prototype.LEFT,
            p5.prototype.BASELINE
        ];
        #leading = 15;
        #font = "sans-serif";
        #font_size = 12;
        #style = p5.prototype.NORMAL;
        #wrap = p5.prototype.WORD;
        /**
     * Sets the current alignment for drawing text. Accepts two
     * values:
     * - first: horizontal alignment (LEFT, CENTER, or RIGHT)
     * - scond: vertical alignment (TOP, BOTTOM, CENTER, or BASELINE).
     *
     * So if you set align="LEFT", you are aligning the left
     * edge of your text to this element's x-coordinate.
     * If you write align="RIGHT, TOP", you are aligning the right edge
     * of your text to this element's x-coordinate and the top edge of the text
     * to this element's y-coordinate.
     * @type {[LEFT|CENTER|RIGHT, TOP|BOTTOM|CENTER|BASELINE]}
     */ get align() {
            return this.#align;
        }
        set align(val) {
            if (Array.isArray(val)) this.pInst.textAlign(...val);
            else this.pInst.textAlign(val);
            this.#align = [
                this.pInst._renderer._textAlign,
                this.pInst._renderer._textBaseline, 
            ];
        }
        /**
     * Sets the spacing, in pixels, between lines of text.
     * @type {number}
     */ get leading() {
            return this.#leading;
        }
        set leading(val) {
            this.pInst.textLeading(val);
            this.#leading = this.pInst._renderer._textLeading;
        }
        /**
     * The current font used by this element. This may be set to a font loaded
     * with load_font() or a string representing a
     * <a href="https://mzl.la/2dOw8WD">web safe font</a>.
     * @type {p5.Font}
     */ get font() {
            return this.#font;
        }
        set font(val) {
            this.pInst.textFont(val);
            this.#font = this.pInst._renderer._textFont;
        }
        /**
     * The font size in pixels.
     * @type {number}
     */ get font_size() {
            return this.#font_size;
        }
        set font_size(val) {
            this.pInst.textSize(val);
            this.#font_size = this.pInst._renderer._textSize;
        }
        /**
     * The style for text.
     * @type {NORMAL|ITALIC|BOLDITALIC}
     */ get style() {
            return this.#style;
        }
        set style(val) {
            this.pInst.textStyle(val);
            this.#style = this.pInst._renderer._textStyle;
        }
        /**
     * Specifies how lines of text are wrapped within a text box. This requires
     * width to be set on this element.
     *
     * WORD wrap style only breaks lines at spaces. A single string without spaces
     * that exceeds the boundaries of the canvas or text area is not truncated,
     * and will overflow the desired area, disappearing at the canvas edge.
     *
     * CHAR wrap style breaks lines wherever needed to stay within the text box.
     *
     * WORD is the default wrap style, and both styles will still break lines at
     * any line breaks specified in the original text. The text height property also
     * still applies to wrapped text in both styles, lines of text that do not fit
     * within the text area will not be drawn to the screen.
     * @type {WORD|CHAR}
     */ get wrap() {
            return this.#wrap;
        }
        set wrap(val) {
            this.pInst.textWrap(val);
            this.#wrap = this.pInst._renderer._textWrap;
        }
        /**
     * The ascent of the current font at its current size. The ascent represents the
     * distance, in pixels, of the tallest character above the baseline. (read-only)
     * @type {number}
     */ get ascent() {
            return this.pInst.textAscent();
        }
        /**
     * The descent of the current font at its current size. The descent represents the
     * distance, in pixels, of the character with the longest descender below the baseline.
     * (read-only)
     * @type {number}
     */ get descent() {
            return this.pInst.textDescent();
        }
    };

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}]},["aZCZP","a0t4e"], "a0t4e", "parcelRequire1ae8")

//# sourceMappingURL=p5.marker.min.js.map
